diff --git a/dom/base/nsXMLHttpRequest.cpp b/dom/base/nsXMLHttpRequest.cpp
index 8cef0c49f4747..c6db18ee99b88 100644
--- a/dom/base/nsXMLHttpRequest.cpp
+++ b/dom/base/nsXMLHttpRequest.cpp
@@ -2044,11 +2044,15 @@ nsXMLHttpRequest::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
           }
           nsCOMPtr<nsIFile> jarFile;
           jarChannel->GetJarFile(getter_AddRefs(jarFile));
-          rv = mArrayBufferBuilder.mapToFileInPackage(file, jarFile);
-          if (NS_WARN_IF(NS_FAILED(rv))) {
+          if (!jarFile) {
             mIsMappedArrayBuffer = false;
           } else {
-            channel->SetContentType(NS_LITERAL_CSTRING("application/mem-mapped"));
+            rv = mArrayBufferBuilder.mapToFileInPackage(file, jarFile);
+            if (NS_WARN_IF(NS_FAILED(rv))) {
+              mIsMappedArrayBuffer = false;
+            } else {
+              channel->SetContentType(NS_LITERAL_CSTRING("application/mem-mapped"));
+            }
           }
         }
       }
diff --git a/modules/libjar/nsIJARChannel.idl b/modules/libjar/nsIJARChannel.idl
index b574bbf7e39b4..bd1977b32cea6 100644
--- a/modules/libjar/nsIJARChannel.idl
+++ b/modules/libjar/nsIJARChannel.idl
@@ -25,7 +25,7 @@ interface nsIJARChannel : nsIChannel
     void setAppURI(in nsIURI uri);
 
     /**
-     * Returns the JAR file.
+     * Returns the JAR file.  May be null if the jar is remote.
      */
     readonly attribute nsIFile jarFile;
 
diff --git a/modules/libjar/nsJARChannel.cpp b/modules/libjar/nsJARChannel.cpp
index 33cdc0b57e208..e363403706c9e 100644
--- a/modules/libjar/nsJARChannel.cpp
+++ b/modules/libjar/nsJARChannel.cpp
@@ -234,7 +234,6 @@ NS_IMPL_ISUPPORTS_INHERITED(nsJARChannel,
                             nsIChannel,
                             nsIStreamListener,
                             nsIRequestObserver,
-                            nsIDownloadObserver,
                             nsIRemoteOpenFileListener,
                             nsIThreadRetargetableRequest,
                             nsIThreadRetargetableStreamListener,
@@ -274,16 +273,21 @@ nsresult
 nsJARChannel::CreateJarInput(nsIZipReaderCache *jarCache, nsJARInputThunk **resultInput)
 {
     MOZ_ASSERT(resultInput);
+    MOZ_ASSERT(mJarFile || mTempMem);
 
     // important to pass a clone of the file since the nsIFile impl is not
     // necessarily MT-safe
     nsCOMPtr<nsIFile> clonedFile;
-    nsresult rv = mJarFile->Clone(getter_AddRefs(clonedFile));
-    if (NS_FAILED(rv))
-        return rv;
+    nsresult rv = NS_OK;
+    if (mJarFile) {
+        rv = mJarFile->Clone(getter_AddRefs(clonedFile));
+        if (NS_FAILED(rv))
+            return rv;
+    }
 
     nsCOMPtr<nsIZipReader> reader;
     if (jarCache) {
+        MOZ_ASSERT(mJarFile);
         if (mInnerJarEntry.IsEmpty())
             rv = jarCache->GetZip(clonedFile, getter_AddRefs(reader));
         else
@@ -295,7 +299,12 @@ nsJARChannel::CreateJarInput(nsIZipReaderCache *jarCache, nsJARInputThunk **resu
         if (NS_FAILED(rv))
             return rv;
 
-        rv = outerReader->Open(clonedFile);
+        if (mJarFile) {
+            rv = outerReader->Open(clonedFile);
+        } else {
+            rv = outerReader->OpenMemory(mTempMem->Elements(),
+                                         mTempMem->Length());
+        }
         if (NS_FAILED(rv))
             return rv;
 
@@ -866,26 +875,24 @@ nsJARChannel::AsyncOpen(nsIStreamListener *listener, nsISupports *ctx)
     if (!mJarFile) {
         // Not a local file...
         // kick off an async download of the base URI...
-        rv = NS_NewDownloader(getter_AddRefs(mDownloader), this);
-        if (NS_SUCCEEDED(rv)) {
-            // Since we might not have a loadinfo on all channels yet
-            // we have to provide default arguments in case mLoadInfo is null;
-            uint32_t loadFlags =
-              mLoadFlags & ~(LOAD_DOCUMENT_URI | LOAD_CALL_CONTENT_SNIFFERS);
-            rv = NS_NewChannelInternal(getter_AddRefs(channel),
-                                       mJarBaseURI,
-                                       mLoadInfo,
-                                       mLoadGroup,
-                                       mCallbacks,
-                                       loadFlags);
-            if (NS_FAILED(rv)) {
-              mIsPending = false;
-              mListenerContext = nullptr;
-              mListener = nullptr;
-              return rv;
-            }
-            channel->AsyncOpen(mDownloader, nullptr);
+        nsCOMPtr<nsIStreamListener> downloader = new MemoryDownloader(this);
+        // Since we might not have a loadinfo on all channels yet
+        // we have to provide default arguments in case mLoadInfo is null;
+        uint32_t loadFlags =
+            mLoadFlags & ~(LOAD_DOCUMENT_URI | LOAD_CALL_CONTENT_SNIFFERS);
+        rv = NS_NewChannelInternal(getter_AddRefs(channel),
+                                   mJarBaseURI,
+                                   mLoadInfo,
+                                   mLoadGroup,
+                                   mCallbacks,
+                                   loadFlags);
+        if (NS_FAILED(rv)) {
+            mIsPending = false;
+            mListenerContext = nullptr;
+            mListener = nullptr;
+            return rv;
         }
+        rv = channel->AsyncOpen(downloader, nullptr);
     } else if (mOpeningRemote) {
         // nothing to do: already asked parent to open file.
     } else {
@@ -964,15 +971,15 @@ nsJARChannel::EnsureChildFd()
 }
 
 //-----------------------------------------------------------------------------
-// nsIDownloadObserver
+// mozilla::net::MemoryDownloader::IObserver
 //-----------------------------------------------------------------------------
 
-NS_IMETHODIMP
-nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
+void
+nsJARChannel::OnDownloadComplete(MemoryDownloader* aDownloader,
                                  nsIRequest    *request,
                                  nsISupports   *context,
                                  nsresult       status,
-                                 nsIFile       *file)
+                                 MemoryDownloader::Data aData)
 {
     nsresult rv;
 
@@ -1050,7 +1057,7 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     }
 
     if (NS_SUCCEEDED(status)) {
-        mJarFile = file;
+        mTempMem = Move(aData);
 
         nsRefPtr<nsJARInputThunk> input;
         rv = CreateJarInput(nullptr, getter_AddRefs(input));
@@ -1066,8 +1073,6 @@ nsJARChannel::OnDownloadComplete(nsIDownloader *downloader,
     if (NS_FAILED(status)) {
         NotifyError(status);
     }
-
-    return NS_OK;
 }
 
 //-----------------------------------------------------------------------------
@@ -1152,7 +1157,6 @@ nsJARChannel::OnStopRequest(nsIRequest *req, nsISupports *ctx, nsresult status)
 
     mPump = 0;
     mIsPending = false;
-    mDownloader = 0; // this may delete the underlying jar file
 
     // Drop notification callbacks to prevent cycles.
     mCallbacks = 0;
diff --git a/modules/libjar/nsJARChannel.h b/modules/libjar/nsJARChannel.h
index 91b91c03a24a3..0cc326d825ad1 100644
--- a/modules/libjar/nsJARChannel.h
+++ b/modules/libjar/nsJARChannel.h
@@ -6,6 +6,7 @@
 #ifndef nsJARChannel_h__
 #define nsJARChannel_h__
 
+#include "mozilla/net/MemoryDownloader.h"
 #include "nsIJARChannel.h"
 #include "nsIJARURI.h"
 #include "nsIInputStreamPump.h"
@@ -14,7 +15,6 @@
 #include "nsIStreamListener.h"
 #include "nsIRemoteOpenFileListener.h"
 #include "nsIZipReader.h"
-#include "nsIDownloader.h"
 #include "nsILoadGroup.h"
 #include "nsILoadInfo.h"
 #include "nsIThreadRetargetableRequest.h"
@@ -31,11 +31,11 @@ class nsJARInputThunk;
 //-----------------------------------------------------------------------------
 
 class nsJARChannel MOZ_FINAL : public nsIJARChannel
-                             , public nsIDownloadObserver
+                             , public mozilla::net::MemoryDownloader::IObserver
                              , public nsIStreamListener
                              , public nsIRemoteOpenFileListener
                              , public nsIThreadRetargetableRequest
-                             , public           nsIThreadRetargetableStreamListener
+                             , public nsIThreadRetargetableStreamListener
                              , public nsHashPropertyBag
 {
 public:
@@ -43,7 +43,6 @@ class nsJARChannel MOZ_FINAL : public nsIJARChannel
     NS_DECL_NSIREQUEST
     NS_DECL_NSICHANNEL
     NS_DECL_NSIJARCHANNEL
-    NS_DECL_NSIDOWNLOADOBSERVER
     NS_DECL_NSIREQUESTOBSERVER
     NS_DECL_NSISTREAMLISTENER
     NS_DECL_NSIREMOTEOPENFILELISTENER
@@ -63,6 +62,12 @@ class nsJARChannel MOZ_FINAL : public nsIJARChannel
     void NotifyError(nsresult aError);
     void FireOnProgress(uint64_t aProgress);
     nsresult SetRemoteNSPRFileDesc(PRFileDesc *fd);
+    virtual void OnDownloadComplete(mozilla::net::MemoryDownloader* aDownloader,
+                                    nsIRequest* aRequest,
+                                    nsISupports* aCtxt,
+                                    nsresult aStatus,
+                                    mozilla::net::MemoryDownloader::Data aData)
+        MOZ_OVERRIDE;
 
 #if defined(PR_LOGGING)
     nsCString                       mSpec;
@@ -95,7 +100,7 @@ class nsJARChannel MOZ_FINAL : public nsIJARChannel
     bool                            mOpeningRemote;
     bool                            mEnsureChildFd;
 
-    nsCOMPtr<nsIStreamListener>     mDownloader;
+    mozilla::net::MemoryDownloader::Data mTempMem;
     nsCOMPtr<nsIInputStreamPump>    mPump;
     // mRequest is only non-null during OnStartRequest, so we'll have a pointer
     // to the request if we get called back via RetargetDeliveryTo.
diff --git a/modules/libjar/test/mochitest/mochitest.ini b/modules/libjar/test/mochitest/mochitest.ini
index 4bfdcea9249cf..9ed0efee735f0 100644
--- a/modules/libjar/test/mochitest/mochitest.ini
+++ b/modules/libjar/test/mochitest/mochitest.ini
@@ -6,3 +6,5 @@ support-files =
   openredirect.sjs
 
 [test_bug403331.html]
+[test_bug1034143_mapped.html]
+run-if = os == 'linux'
diff --git a/modules/libjar/test/mochitest/test_bug1034143_mapped.html b/modules/libjar/test/mochitest/test_bug1034143_mapped.html
new file mode 100644
index 0000000000000..d65179b3b42b6
--- /dev/null
+++ b/modules/libjar/test/mochitest/test_bug1034143_mapped.html
@@ -0,0 +1,52 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+https://bugzilla.mozilla.org/show_bug.cgi?id=1034143
+-->
+<head>
+  <meta charset="utf-8">
+  <title>Test for Bug 945152</title>
+  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
+</head>
+<body>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1034143">Mozilla Bug 1034143</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+<script type="application/javascript;version=1.7">
+// Ensure that XMLHttpRequest's memory-mapping code can handle a case
+// where the nsIJARChannel's jarFile property is null, but which is
+// otherwise eligible for bug 945152's memory-mapping optimization.
+
+function runTest() {
+  const jarURL = "jar:http://example.org/tests/dom/base/test/file_bug945152.jar!/data_1.txt";
+  let xhr = new XMLHttpRequest({ mozAnon: true, mozSystem: true });
+  xhr.open("GET", jarURL);
+  xhr.onerror = function onerror(e) {
+    ok(false, "JAR XHR failed: " + e.status);
+    SimpleTest.finish();
+  };
+  xhr.onload = function onload(e) {
+    ok(xhr.status == 200, "Status is 200");
+    let ct = xhr.getResponseHeader("Content-Type");
+    ok(ct.indexOf("mem-mapped") == -1, "Data is not memory-mapped");
+    SimpleTest.finish();
+  };
+  xhr.responseType = 'arraybuffer';
+  xhr.send();
+}
+
+SimpleTest.waitForExplicitFinish();
+
+addLoadEvent(function() {
+  SpecialPowers.pushPrefEnv({"set": [["dom.mapped_arraybuffer.enabled", true]]}, function() {
+    SpecialPowers.pushPermissions([{'type': 'systemXHR', 'allow': true, 'context': document}], runTest);
+  });
+});
+</script>
+</pre>
+</body>
+</html>
