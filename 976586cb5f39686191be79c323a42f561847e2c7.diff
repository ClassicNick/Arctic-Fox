diff --git a/dom/base/nsJSEnvironment.cpp b/dom/base/nsJSEnvironment.cpp
index b68129ef2b2d..861bf9b9fd3d 100644
--- a/dom/base/nsJSEnvironment.cpp
+++ b/dom/base/nsJSEnvironment.cpp
@@ -1092,12 +1092,12 @@ nsJSContext::AddSupportsPrimitiveTojsvals(nsISupports *aArg, JS::Value *aArgv)
     case nsISupportsPrimitive::TYPE_PRTIME :
     case nsISupportsPrimitive::TYPE_VOID : {
       NS_WARNING("Unsupported primitive type used");
-      *aArgv = JSVAL_NULL;
+      aArgv->setNull();
       break;
     }
     default : {
       NS_WARNING("Unknown primitive type used");
-      *aArgv = JSVAL_NULL;
+      aArgv->setNull();
       break;
     }
   }
diff --git a/dom/devicestorage/nsDeviceStorage.cpp b/dom/devicestorage/nsDeviceStorage.cpp
index 1ba45430d1e9..07dd2492c23e 100644
--- a/dom/devicestorage/nsDeviceStorage.cpp
+++ b/dom/devicestorage/nsDeviceStorage.cpp
@@ -1913,12 +1913,12 @@ nsIFileToJsval(nsPIDOMWindow* aWindow, DeviceStorageFile* aFile)
   MOZ_ASSERT(aWindow);
 
   if (!aFile) {
-    return JSVAL_NULL;
+    return JS::NullValue();
   }
 
   if (aFile->mEditable) {
     // TODO - needs janv's file handle support.
-    return JSVAL_NULL;
+    return JS::NullValue();
   }
 
   nsString fullPath;
@@ -2531,7 +2531,7 @@ class PostResultEvent : public nsRunnable
     }
 
     AutoJSContext cx;
-    JS::Rooted<JS::Value> result(cx, JSVAL_NULL);
+    JS::Rooted<JS::Value> result(cx, JS::NullValue());
 
     if (mFile) {
       result = nsIFileToJsval(window, mFile);
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
index 4617a0f1e25c..4e06d18f2642 100644
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -503,7 +503,7 @@ TabChildBase::DispatchMessageManagerMessage(const nsAString& aMessageName,
                                             const nsAString& aJSONData)
 {
     AutoSafeJSContext cx;
-    JS::Rooted<JS::Value> json(cx, JSVAL_NULL);
+    JS::Rooted<JS::Value> json(cx, JS::NullValue());
     StructuredCloneData cloneData;
     JSAutoStructuredCloneBuffer buffer;
     if (JS_ParseJSON(cx,
diff --git a/dom/mobilemessage/MobileMessageCallback.cpp b/dom/mobilemessage/MobileMessageCallback.cpp
index 10b554bd3442..47bd301bfaa7 100644
--- a/dom/mobilemessage/MobileMessageCallback.cpp
+++ b/dom/mobilemessage/MobileMessageCallback.cpp
@@ -205,7 +205,7 @@ MobileMessageCallback::NotifyMessageDeleted(bool *aDeleted, uint32_t aSize)
 {
   if (aSize == 1) {
     AutoJSContext cx;
-    JS::Rooted<JS::Value> val(cx, aDeleted[0] ? JSVAL_TRUE : JSVAL_FALSE);
+    JS::Rooted<JS::Value> val(cx, JS::BooleanValue(*aDeleted));
     return NotifySuccess(val);
   }
 
@@ -234,7 +234,7 @@ NS_IMETHODIMP
 MobileMessageCallback::NotifyMessageMarkedRead(bool aRead)
 {
   AutoJSContext cx;
-  JS::Rooted<JS::Value> val(cx, aRead ? JSVAL_TRUE : JSVAL_FALSE);
+  JS::Rooted<JS::Value> val(cx, JS::BooleanValue(aRead));
   return NotifySuccess(val);
 }
 
diff --git a/dom/plugins/base/nsJSNPRuntime.cpp b/dom/plugins/base/nsJSNPRuntime.cpp
index 52f700c86f59..11c66bcc6f05 100644
--- a/dom/plugins/base/nsJSNPRuntime.cpp
+++ b/dom/plugins/base/nsJSNPRuntime.cpp
@@ -487,7 +487,7 @@ NPVariantToJSVal(NPP npp, JSContext *cx, const NPVariant *variant)
   case NPVariantType_Void :
     return JS::UndefinedValue();
   case NPVariantType_Null :
-    return JSVAL_NULL;
+    return JS::NullValue();
   case NPVariantType_Bool :
     return BOOLEAN_TO_JSVAL(NPVARIANT_TO_BOOLEAN(*variant));
   case NPVariantType_Int32 :
diff --git a/dom/system/OSFileConstants.cpp b/dom/system/OSFileConstants.cpp
index fc9dbb9602aa..e3c63c52066e 100644
--- a/dom/system/OSFileConstants.cpp
+++ b/dom/system/OSFileConstants.cpp
@@ -915,7 +915,7 @@ bool DefineOSFileConstants(JSContext *cx, JS::Handle<JSObject*> global)
 #endif // defined(MOZ_WIDGET_GONK)
 
 #if defined(DEBUG)
-  JS::Rooted<JS::Value> valDebug(cx, JSVAL_TRUE);
+  JS::Rooted<JS::Value> valDebug(cx, JS::TrueValue());
   if (!JS_SetProperty(cx, objSys, "DEBUG", valDebug)) {
     return false;
   }
diff --git a/dom/workers/XMLHttpRequest.cpp b/dom/workers/XMLHttpRequest.cpp
index 6b61e824fe99..f422b6a2dd7e 100644
--- a/dom/workers/XMLHttpRequest.cpp
+++ b/dom/workers/XMLHttpRequest.cpp
@@ -1187,7 +1187,7 @@ EventRunnable::PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
   if (NS_SUCCEEDED(mResponseTextResult)) {
     mResponseResult = mResponseTextResult;
     if (mResponseText.IsVoid()) {
-      mResponse = JSVAL_NULL;
+      mResponse.setNull();
     }
   }
   else {
diff --git a/dom/workers/XMLHttpRequest.h b/dom/workers/XMLHttpRequest.h
index a3c4d14b0d68..330cb5f89bc3 100644
--- a/dom/workers/XMLHttpRequest.h
+++ b/dom/workers/XMLHttpRequest.h
@@ -251,7 +251,7 @@ class XMLHttpRequest final: public nsXHREventTarget,
   NullResponseText()
   {
     mStateData.mResponseText.SetIsVoid(true);
-    mStateData.mResponse = JSVAL_NULL;
+    mStateData.mResponse.setNull();
   }
 
   bool MozAnon() const
diff --git a/ipc/testshell/XPCShellEnvironment.cpp b/ipc/testshell/XPCShellEnvironment.cpp
index c1b2c0ed3f8f..1580c4197d03 100644
--- a/ipc/testshell/XPCShellEnvironment.cpp
+++ b/ipc/testshell/XPCShellEnvironment.cpp
@@ -367,7 +367,7 @@ XPCShellEnvironment::ProcessFile(JSContext *cx,
             JSErrorReporter older;
 
             ok = JS_ExecuteScript(cx, script, &result);
-            if (ok && result != JSVAL_VOID) {
+            if (ok && !result.isUndefined()) {
                 /* Suppress error reports from JS::ToString(). */
                 older = JS_SetErrorReporter(JS_GetRuntime(cx), nullptr);
                 str = JS::ToString(cx, result);
@@ -584,7 +584,7 @@ XPCShellEnvironment::EvaluateString(const nsString& aString,
 
   JS::Rooted<JS::Value> result(cx);
   bool ok = JS_ExecuteScript(cx, script, &result);
-  if (ok && result != JSVAL_VOID) {
+  if (ok && !result.isUndefined()) {
       JSErrorReporter old = JS_SetErrorReporter(JS_GetRuntime(cx), nullptr);
       JSString* str = JS::ToString(cx, result);
       nsAutoJSString autoStr;
diff --git a/js/ipc/JavaScriptShared.cpp b/js/ipc/JavaScriptShared.cpp
index c591b54954c9..300e375db0e6 100644
--- a/js/ipc/JavaScriptShared.cpp
+++ b/js/ipc/JavaScriptShared.cpp
@@ -270,7 +270,7 @@ JavaScriptShared::toVariant(JSContext* cx, JS::HandleValue from, JSVariant* to)
       {
         RootedObject obj(cx, from.toObjectOrNull());
         if (!obj) {
-            MOZ_ASSERT(from == JSVAL_NULL);
+            MOZ_ASSERT(from.isNull());
             *to = NullVariant();
             return true;
         }
diff --git a/js/public/Value.h b/js/public/Value.h
index c2bd82420146..6934f1d10e61 100644
--- a/js/public/Value.h
+++ b/js/public/Value.h
@@ -1676,6 +1676,7 @@ class ValueOperations
     bool isFalse() const { return value()->isFalse(); }
     bool isNumber() const { return value()->isNumber(); }
     bool isInt32() const { return value()->isInt32(); }
+    bool isInt32(int32_t i32) const { return value()->isInt32(i32); }
     bool isDouble() const { return value()->isDouble(); }
     bool isString() const { return value()->isString(); }
     bool isSymbol() const { return value()->isSymbol(); }
@@ -1998,17 +1999,6 @@ PRIVATE_TO_JSVAL(void* ptr)
     return IMPL_TO_JSVAL(PRIVATE_PTR_TO_JSVAL_IMPL(ptr));
 }
 
-// JS constants. For efficiency, prefer predicates (e.g. v.isNull()) and
-// constructing values from scratch (e.g. Int32Value(0)).  These constants are
-// stored in memory and initialized at startup, so testing against them and
-// using them requires memory loads and will be correspondingly slow.
-extern JS_PUBLIC_DATA(const jsval) JSVAL_NULL;
-extern JS_PUBLIC_DATA(const jsval) JSVAL_ZERO;
-extern JS_PUBLIC_DATA(const jsval) JSVAL_ONE;
-extern JS_PUBLIC_DATA(const jsval) JSVAL_FALSE;
-extern JS_PUBLIC_DATA(const jsval) JSVAL_TRUE;
-extern JS_PUBLIC_DATA(const jsval) JSVAL_VOID;
-
 namespace JS {
 
 extern JS_PUBLIC_DATA(const HandleValue) NullHandleValue;
diff --git a/js/src/ctypes/CTypes.cpp b/js/src/ctypes/CTypes.cpp
index 53dbc3d14260..9dd4445b4c77 100644
--- a/js/src/ctypes/CTypes.cpp
+++ b/js/src/ctypes/CTypes.cpp
@@ -1889,7 +1889,8 @@ InitTypeClasses(JSContext* cx, HandleObject ctypesObj)
   // Create objects representing the special types void_t and voidptr_t.
   RootedObject typeObj(cx,
     CType::DefineBuiltin(cx, ctypesObj, "void_t", CTypeProto, CDataProto, "void",
-                         TYPE_void_t, JSVAL_VOID, JSVAL_VOID, &ffi_type_void));
+                         TYPE_void_t, JS::UndefinedValue(), JS::UndefinedValue(),
+                         &ffi_type_void));
   if (!typeObj)
     return false;
 
@@ -4191,7 +4192,7 @@ CType::GetSafeSize(JSObject* obj, size_t* result)
 
   jsval size = JS_GetReservedSlot(obj, SLOT_SIZE);
 
-  // The "size" property can be an int, a double, or JSVAL_VOID
+  // The "size" property can be an int, a double, or JS::UndefinedValue()
   // (for arrays of undefined length), and must always fit in a size_t.
   if (size.isInt32()) {
     *result = size.toInt32();
@@ -4215,9 +4216,10 @@ CType::GetSize(JSObject* obj)
 
   MOZ_ASSERT(!size.isUndefined());
 
-  // The "size" property can be an int, a double, or JSVAL_VOID
+  // The "size" property can be an int, a double, or JS::UndefinedValue()
   // (for arrays of undefined length), and must always fit in a size_t.
-  // For callers who know it can never be JSVAL_VOID, return a size_t directly.
+  // For callers who know it can never be JS::UndefinedValue(), return a size_t
+  // directly.
   if (size.isInt32())
     return size.toInt32();
   return Convert<size_t>(size.toDouble());
@@ -4230,7 +4232,7 @@ CType::IsSizeDefined(JSObject* obj)
 
   jsval size = JS_GetReservedSlot(obj, SLOT_SIZE);
 
-  // The "size" property can be an int, a double, or JSVAL_VOID
+  // The "size" property can be an int, a double, or JS::UndefinedValue()
   // (for arrays of undefined length), and must always fit in a size_t.
   MOZ_ASSERT(size.isInt32() || size.isDouble() || size.isUndefined());
   return !size.isUndefined();
@@ -4709,7 +4711,7 @@ PointerType::ConstructData(JSContext* cx,
   // The third argument is an optional error sentinel that js-ctypes will return
   // if an exception is raised while executing the closure. The type must match
   // the return type of the callback.
-  jsval errVal = JSVAL_VOID;
+  Value errVal = JS::UndefinedValue();
   if (args.length() == 3)
     errVal = args[2];
 
@@ -4930,8 +4932,8 @@ ArrayType::CreateInternal(JSContext* cx,
     return nullptr;
   }
 
-  RootedValue sizeVal(cx, JSVAL_VOID);
-  RootedValue lengthVal(cx, JSVAL_VOID);
+  RootedValue sizeVal(cx, JS::UndefinedValue());
+  RootedValue lengthVal(cx, JS::UndefinedValue());
   if (lengthDefined) {
     // Check for overflow, and convert to an int or double as required.
     size_t size = length * baseSize;
@@ -5084,7 +5086,7 @@ ArrayType::GetSafeLength(JSObject* obj, size_t* result)
 
   jsval length = JS_GetReservedSlot(obj, SLOT_LENGTH);
 
-  // The "length" property can be an int, a double, or JSVAL_VOID
+  // The "length" property can be an int, a double, or JS::UndefinedValue()
   // (for arrays of undefined length), and must always fit in a size_t.
   if (length.isInt32()) {
     *result = length.toInt32();
@@ -5109,9 +5111,10 @@ ArrayType::GetLength(JSObject* obj)
 
   MOZ_ASSERT(!length.isUndefined());
 
-  // The "length" property can be an int, a double, or JSVAL_VOID
+  // The "length" property can be an int, a double, or JS::UndefinedValue()
   // (for arrays of undefined length), and must always fit in a size_t.
-  // For callers who know it can never be JSVAL_VOID, return a size_t directly.
+  // For callers who know it can never be JS::UndefinedValue(), return a size_t
+  // directly.
   if (length.isInt32())
     return length.toInt32();
   return Convert<size_t>(length.toDouble());
@@ -5441,7 +5444,8 @@ StructType::Create(JSContext* cx, unsigned argc, jsval* vp)
   // non-instantiable as CData, will have no 'prototype' property, and will
   // have undefined size and alignment and no ffi_type.
   RootedObject result(cx, CType::Create(cx, typeProto, nullptr, TYPE_struct,
-                                        name.toString(), JSVAL_VOID, JSVAL_VOID, nullptr));
+                                        name.toString(), JS::UndefinedValue(),
+                                        JS::UndefinedValue(), nullptr));
   if (!result)
     return false;
 
@@ -6426,7 +6430,8 @@ FunctionType::CreateInternal(JSContext* cx,
 
   // Create a new CType object with the common properties and slots.
   RootedObject typeObj(cx, CType::Create(cx, typeProto, dataProto, TYPE_function,
-                                         nullptr, JSVAL_VOID, JSVAL_VOID, nullptr));
+                                         nullptr, JS::UndefinedValue(),
+                                         JS::UndefinedValue(), nullptr));
   if (!typeObj)
     return nullptr;
 
@@ -7951,7 +7956,7 @@ CDataFinalizer::Methods::Dispose(JSContext* cx, unsigned argc, jsval* vp)
   MOZ_ASSERT(CType::GetTypeCode(objCodeType) == TYPE_function);
 
   RootedObject resultType(cx, FunctionType::GetFunctionInfo(objCodeType)->mReturnType);
-  RootedValue result(cx, JSVAL_VOID);
+  RootedValue result(cx, JS::UndefinedValue());
 
   int errnoStatus;
 #if defined(XP_WIN)
@@ -8029,7 +8034,7 @@ CDataFinalizer::Cleanup(CDataFinalizer::Private* p, JSObject* obj)
 
   JS_SetPrivate(obj, nullptr);
   for (int i = 0; i < CDATAFINALIZER_SLOTS; ++i) {
-    JS_SetReservedSlot(obj, i, JSVAL_NULL);
+    JS_SetReservedSlot(obj, i, JS::NullValue());
   }
 }
 
diff --git a/js/src/jsapi-tests/testArgumentsObject.cpp b/js/src/jsapi-tests/testArgumentsObject.cpp
index 754fea580f03..5880d21ceab3 100644
--- a/js/src/jsapi-tests/testArgumentsObject.cpp
+++ b/js/src/jsapi-tests/testArgumentsObject.cpp
@@ -94,7 +94,7 @@ ExhaustiveTest(const char funcode[])
             for (size_t k = 0; k < j; k++)
                 CHECK_SAME(elems[k], INT_TO_JSVAL(i + k));
             for (size_t k = j; k < MAX_ELEMS - 1; k++)
-                CHECK_SAME(elems[k], JSVAL_NULL);
+                CHECK(elems[k].isNull());
             CHECK_SAME(elems[MAX_ELEMS - 1], INT_TO_JSVAL(42));
         }
     }
diff --git a/js/src/jsapi-tests/testArrayBuffer.cpp b/js/src/jsapi-tests/testArrayBuffer.cpp
index 693d6ce5f252..f83a2b3698f6 100644
--- a/js/src/jsapi-tests/testArrayBuffer.cpp
+++ b/js/src/jsapi-tests/testArrayBuffer.cpp
@@ -68,9 +68,9 @@ BEGIN_TEST(testArrayBuffer_bug720949_steal)
         CHECK(JS_GetProperty(cx, view, "length", &v));
         CHECK_SAME(v, INT_TO_JSVAL(0));
         CHECK_EQUAL(JS_GetArrayBufferByteLength(obj), 0u);
-        v = JSVAL_VOID;
+        v.setUndefined();
         JS_GetElement(cx, obj, 0, &v);
-        CHECK_SAME(v, JSVAL_VOID);
+        CHECK(v.isUndefined());
 
         // Transfer to a new ArrayBuffer
         JS::RootedObject dst(cx, JS_NewArrayBufferWithContents(cx, size, contents));
diff --git a/js/src/jsapi-tests/testDeepFreeze.cpp b/js/src/jsapi-tests/testDeepFreeze.cpp
index efc7183ebb6b..d6623775f609 100644
--- a/js/src/jsapi-tests/testDeepFreeze.cpp
+++ b/js/src/jsapi-tests/testDeepFreeze.cpp
@@ -14,7 +14,7 @@ BEGIN_TEST(testDeepFreeze_bug535703)
     JS::RootedObject obj(cx, v.toObjectOrNull());
     CHECK(JS_DeepFreezeObject(cx, obj));  // don't crash
     EVAL("Object.isFrozen(x)", &v);
-    CHECK_SAME(v, JSVAL_TRUE);
+    CHECK(v.isTrue());
     return true;
 }
 END_TEST(testDeepFreeze_bug535703)
@@ -33,9 +33,9 @@ BEGIN_TEST(testDeepFreeze_deep)
 
     JS::RootedValue b(cx);
     EVAL("Object.isFrozen(a)", &b);
-    CHECK_SAME(b, JSVAL_TRUE);
+    CHECK(b.isTrue());
     EVAL("Object.isFrozen(o)", &b);
-    CHECK_SAME(b, JSVAL_TRUE);
+    CHECK(b.isTrue());
     return true;
 }
 END_TEST(testDeepFreeze_deep)
@@ -52,9 +52,9 @@ BEGIN_TEST(testDeepFreeze_loop)
 
     JS::RootedValue b(cx);
     EVAL("Object.isFrozen(x)", &b);
-    CHECK_SAME(b, JSVAL_TRUE);
+    CHECK(b.isTrue());
     EVAL("Object.isFrozen(y)", &b);
-    CHECK_SAME(b, JSVAL_TRUE);
+    CHECK(b.isTrue());
     return true;
 }
 END_TEST(testDeepFreeze_loop)
diff --git a/js/src/jsapi-tests/testFunctionProperties.cpp b/js/src/jsapi-tests/testFunctionProperties.cpp
index 20a098ccc490..e79f5ec28879 100644
--- a/js/src/jsapi-tests/testFunctionProperties.cpp
+++ b/js/src/jsapi-tests/testFunctionProperties.cpp
@@ -16,10 +16,10 @@ BEGIN_TEST(testFunctionProperties)
 
     JS::RootedValue y(cx);
     CHECK(JS_GetProperty(cx, obj, "arguments", &y));
-    CHECK_SAME(y, JSVAL_NULL);
+    CHECK(y.isNull());
 
     CHECK(JS_GetProperty(cx, obj, "caller", &y));
-    CHECK_SAME(y, JSVAL_NULL);
+    CHECK(y.isNull());
 
     return true;
 }
diff --git a/js/src/jsapi-tests/testLookup.cpp b/js/src/jsapi-tests/testLookup.cpp
index f912a2fac896..09900af72055 100644
--- a/js/src/jsapi-tests/testLookup.cpp
+++ b/js/src/jsapi-tests/testLookup.cpp
@@ -19,7 +19,7 @@ BEGIN_TEST(testLookup_bug522590)
 
     // Calling mkobj() multiple times must create multiple functions in ES5.
     EVAL("mkobj().f !== mkobj().f", &x);
-    CHECK_SAME(x, JSVAL_TRUE);
+    CHECK(x.isTrue());
 
     // Now make x.f a method.
     EVAL("mkobj()", &x);
@@ -86,9 +86,9 @@ BEGIN_TEST(testLookup_bug570195)
     CHECK(JS_DefineProperty(cx, global, "document", obj, 0));
     JS::RootedValue v(cx);
     EVAL("document.all ? true : false", &v);
-    CHECK_SAME(v, JSVAL_FALSE);
+    CHECK(v.isFalse());
     EVAL("document.hasOwnProperty('all')", &v);
-    CHECK_SAME(v, JSVAL_TRUE);
+    CHECK(v.isTrue());
     return true;
 }
 END_TEST(testLookup_bug570195)
diff --git a/js/src/jsapi-tests/testLooselyEqual.cpp b/js/src/jsapi-tests/testLooselyEqual.cpp
index 3e09bf86c946..0bbca1a7ae1c 100644
--- a/js/src/jsapi-tests/testLooselyEqual.cpp
+++ b/js/src/jsapi-tests/testLooselyEqual.cpp
@@ -55,8 +55,8 @@ struct LooseEqualityData
         sNaN = DOUBLE_TO_JSVAL(numeric_limits<double>::signaling_NaN());
         d42 = DOUBLE_TO_JSVAL(42.0);
         i42 = INT_TO_JSVAL(42);
-        undef = JSVAL_VOID;
-        null = JSVAL_NULL;
+        undef = JS::UndefinedValue();
+        null = JS::NullValue();
         obj = OBJECT_TO_JSVAL(JS::CurrentGlobalOrNull(cx));
         poszero = DOUBLE_TO_JSVAL(0.0);
         negzero = DOUBLE_TO_JSVAL(-0.0);
diff --git a/js/src/jsapi-tests/testNewObject.cpp b/js/src/jsapi-tests/testNewObject.cpp
index 335c3736b8c2..77c115d9be86 100644
--- a/js/src/jsapi-tests/testNewObject.cpp
+++ b/js/src/jsapi-tests/testNewObject.cpp
@@ -106,7 +106,7 @@ BEGIN_TEST(testNewObject_1)
     obj = JS_New(cx, ctor, JS::HandleValueArray::subarray(argv, 0, 3));
     CHECK(obj);
     CHECK(JS_GetElement(cx, ctor, 0, &v));
-    CHECK_SAME(v, JSVAL_ZERO);
+    CHECK(v.isInt32(0));
 
     return true;
 }
diff --git a/js/src/jsapi-tests/testObjectEmulatingUndefined.cpp b/js/src/jsapi-tests/testObjectEmulatingUndefined.cpp
index 54b9ebf279fd..8ba4b4b634a5 100644
--- a/js/src/jsapi-tests/testObjectEmulatingUndefined.cpp
+++ b/js/src/jsapi-tests/testObjectEmulatingUndefined.cpp
@@ -29,10 +29,10 @@ BEGIN_TEST(testObjectEmulatingUndefined_truthy)
     JS::RootedValue result(cx);
 
     EVAL("if (new ObjectEmulatingUndefined()) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_FALSE);
+    CHECK(result.isFalse());
 
     EVAL("if (!new ObjectEmulatingUndefined()) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("var obj = new ObjectEmulatingUndefined(); \n"
          "var res = []; \n"
@@ -40,7 +40,7 @@ BEGIN_TEST(testObjectEmulatingUndefined_truthy)
          "  res.push(Boolean(obj)); \n"
          "res.every(function(v) { return v === false; });",
          &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     return true;
 }
@@ -55,16 +55,16 @@ BEGIN_TEST(testObjectEmulatingUndefined_equal)
     JS::RootedValue result(cx);
 
     EVAL("if (new ObjectEmulatingUndefined() == undefined) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("if (new ObjectEmulatingUndefined() == null) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("if (new ObjectEmulatingUndefined() != undefined) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_FALSE);
+    CHECK(result.isFalse());
 
     EVAL("if (new ObjectEmulatingUndefined() != null) true; else false;", &result);
-    CHECK_SAME(result, JSVAL_FALSE);
+    CHECK(result.isFalse());
 
     EVAL("var obj = new ObjectEmulatingUndefined(); \n"
          "var res = []; \n"
@@ -72,7 +72,7 @@ BEGIN_TEST(testObjectEmulatingUndefined_equal)
          "  res.push(obj == undefined); \n"
          "res.every(function(v) { return v === true; });",
          &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("var obj = new ObjectEmulatingUndefined(); \n"
          "var res = []; \n"
@@ -80,7 +80,7 @@ BEGIN_TEST(testObjectEmulatingUndefined_equal)
          "  res.push(obj == null); \n"
          "res.every(function(v) { return v === true; });",
          &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("var obj = new ObjectEmulatingUndefined(); \n"
          "var res = []; \n"
@@ -88,7 +88,7 @@ BEGIN_TEST(testObjectEmulatingUndefined_equal)
          "  res.push(obj != undefined); \n"
          "res.every(function(v) { return v === false; });",
          &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     EVAL("var obj = new ObjectEmulatingUndefined(); \n"
          "var res = []; \n"
@@ -96,7 +96,7 @@ BEGIN_TEST(testObjectEmulatingUndefined_equal)
          "  res.push(obj != null); \n"
          "res.every(function(v) { return v === false; });",
          &result);
-    CHECK_SAME(result, JSVAL_TRUE);
+    CHECK(result.isTrue());
 
     return true;
 }
diff --git a/js/src/jsapi-tests/testParseJSON.cpp b/js/src/jsapi-tests/testParseJSON.cpp
index 13537b6a203e..7fc56d183de4 100644
--- a/js/src/jsapi-tests/testParseJSON.cpp
+++ b/js/src/jsapi-tests/testParseJSON.cpp
@@ -39,13 +39,13 @@ BEGIN_TEST(testParseJSON_success)
 {
     // Primitives
     JS::RootedValue expected(cx);
-    expected = JSVAL_TRUE;
+    expected = JS::TrueValue();
     CHECK(TryParse(cx, "true", expected));
 
-    expected = JSVAL_FALSE;
+    expected = JS::FalseValue();
     CHECK(TryParse(cx, "false", expected));
 
-    expected = JSVAL_NULL;
+    expected = JS::NullValue();
     CHECK(TryParse(cx, "null", expected));
 
     expected = INT_TO_JSVAL(0);
@@ -107,16 +107,16 @@ BEGIN_TEST(testParseJSON_success)
     obj = &v.toObject();
     CHECK(JS_IsArrayObject(cx, obj));
     CHECK(JS_GetProperty(cx, obj, "length", &v2));
-    CHECK_SAME(v2, JSVAL_ZERO);
+    CHECK(v2.isInt32(0));
 
     CHECK(Parse(cx, "[1]", &v));
     CHECK(v.isObject());
     obj = &v.toObject();
     CHECK(JS_IsArrayObject(cx, obj));
     CHECK(JS_GetProperty(cx, obj, "0", &v2));
-    CHECK_SAME(v2, JSVAL_ONE);
+    CHECK(v2.isInt32(1));
     CHECK(JS_GetProperty(cx, obj, "length", &v2));
-    CHECK_SAME(v2, JSVAL_ONE);
+    CHECK(v2.isInt32(1));
 
 
     // Objects
@@ -361,7 +361,7 @@ TryParse(JSContext* cx, const char (&input)[N], JS::HandleValue filter)
     JS::RootedValue v(cx);
     str = input;
     CHECK(JS_ParseJSONWithReviver(cx, str.chars(), str.length(), filter, &v));
-    CHECK_SAME(v, JSVAL_NULL);
+    CHECK(v.isNull());
     return true;
 }
 END_TEST(testParseJSON_reviver)
diff --git a/js/src/jsapi-tests/testResolveRecursion.cpp b/js/src/jsapi-tests/testResolveRecursion.cpp
index 1cc98e7c8744..bd59faeed37e 100644
--- a/js/src/jsapi-tests/testResolveRecursion.cpp
+++ b/js/src/jsapi-tests/testResolveRecursion.cpp
@@ -42,7 +42,7 @@ BEGIN_TEST(testResolveRecursion)
     /* Start the essence of the test via invoking the first resolve hook. */
     JS::RootedValue v(cx);
     EVAL("obj1.x", &v);
-    CHECK_SAME(v, JSVAL_FALSE);
+    CHECK(v.isFalse());
     CHECK_EQUAL(resolveEntryCount, 4);
     CHECK_EQUAL(resolveExitCount, 4);
 
@@ -86,7 +86,7 @@ doResolve(JS::HandleObject obj, JS::HandleId id, bool* resolvedp)
             /* First resolve hook invocation. */
             CHECK_EQUAL(resolveEntryCount, 1);
             EVAL("obj2.y = true", &v);
-            CHECK_SAME(v, JSVAL_TRUE);
+            CHECK(v.isTrue());
             CHECK(JS_DefinePropertyById(cx, obj, id, JS::FalseHandleValue, JSPROP_RESOLVING));
             *resolvedp = true;
             return true;
@@ -103,7 +103,7 @@ doResolve(JS::HandleObject obj, JS::HandleId id, bool* resolvedp)
             EVAL("obj1.x", &v);
             CHECK(v.isUndefined());
             EVAL("obj1.y", &v);
-            CHECK_SAME(v, JSVAL_ZERO);
+            CHECK(v.isInt32(0));
             *resolvedp = true;
             return true;
         }
@@ -118,7 +118,7 @@ doResolve(JS::HandleObject obj, JS::HandleId id, bool* resolvedp)
             EVAL("obj2.x", &v);
             CHECK(v.isUndefined());
             EVAL("obj1.y = 0", &v);
-            CHECK_SAME(v, JSVAL_ZERO);
+            CHECK(v.isInt32(0));
             *resolvedp = true;
             return true;
         }
diff --git a/js/src/jsapi-tests/testXDR.cpp b/js/src/jsapi-tests/testXDR.cpp
index ab1804848b04..e1cc401337f1 100644
--- a/js/src/jsapi-tests/testXDR.cpp
+++ b/js/src/jsapi-tests/testXDR.cpp
@@ -67,7 +67,7 @@ BEGIN_TEST(testXDR_bug506491)
 
     // confirm
     EVAL("f() === 'ok';\n", &v2);
-    JS::RootedValue trueval(cx, JSVAL_TRUE);
+    JS::RootedValue trueval(cx, JS::TrueValue());
     CHECK_SAME(v2, trueval);
     return true;
 }
diff --git a/js/src/jsapi.cpp b/js/src/jsapi.cpp
index 98a6519c021b..bc5a561332c6 100644
--- a/js/src/jsapi.cpp
+++ b/js/src/jsapi.cpp
@@ -1439,7 +1439,7 @@ JS_ComputeThis(JSContext* cx, jsval* vp)
     assertSameCompartment(cx, JSValueArray(vp, 2));
     CallReceiver call = CallReceiverFromVp(vp);
     if (!BoxNonStrictThis(cx, call))
-        return JSVAL_NULL;
+        return NullValue();
     return call.thisv();
 }
 
diff --git a/js/src/jsapi.h b/js/src/jsapi.h
index 3a486d401f69..a2492935c2d4 100644
--- a/js/src/jsapi.h
+++ b/js/src/jsapi.h
@@ -2514,7 +2514,7 @@ struct JSPropertyDescriptor {
     JS::Value value;
 
     JSPropertyDescriptor()
-      : obj(nullptr), attrs(0), getter(nullptr), setter(nullptr), value(JSVAL_VOID)
+      : obj(nullptr), attrs(0), getter(nullptr), setter(nullptr), value(JS::UndefinedValue())
     {}
 
     void trace(JSTracer* trc);
diff --git a/js/src/vm/Value.cpp b/js/src/vm/Value.cpp
index a2e41efca55e..4f47d9a57f2e 100644
--- a/js/src/vm/Value.cpp
+++ b/js/src/vm/Value.cpp
@@ -6,12 +6,10 @@
 
 #include "js/Value.h"
 
-const jsval JSVAL_NULL  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_NULL,      0));
-const jsval JSVAL_ZERO  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     0));
-const jsval JSVAL_ONE   = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_INT32,     1));
-const jsval JSVAL_FALSE = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   false));
-const jsval JSVAL_TRUE  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   true));
-const jsval JSVAL_VOID  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0));
+static const jsval JSVAL_NULL  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_NULL,      0));
+static const jsval JSVAL_FALSE = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   false));
+static const jsval JSVAL_TRUE  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_BOOLEAN,   true));
+static const jsval JSVAL_VOID  = IMPL_TO_JSVAL(BUILD_JSVAL(JSVAL_TAG_UNDEFINED, 0));
 
 namespace JS {
 
diff --git a/js/xpconnect/src/XPCConvert.cpp b/js/xpconnect/src/XPCConvert.cpp
index 3f07318e7898..367602b717f6 100644
--- a/js/xpconnect/src/XPCConvert.cpp
+++ b/js/xpconnect/src/XPCConvert.cpp
@@ -1274,7 +1274,7 @@ XPCConvert::NativeArray2JS(MutableHandleValue d, const void** s,
         *pErr = NS_ERROR_XPC_BAD_CONVERT_NATIVE;
 
     uint32_t i;
-    RootedValue current(cx, JSVAL_NULL);
+    RootedValue current(cx, JS::NullValue());
 
 #define POPULATE(_t)                                                                    \
     PR_BEGIN_MACRO                                                                      \
diff --git a/js/xpconnect/src/XPCWrappedNative.cpp b/js/xpconnect/src/XPCWrappedNative.cpp
index 5303aded3986..688b5fd89822 100644
--- a/js/xpconnect/src/XPCWrappedNative.cpp
+++ b/js/xpconnect/src/XPCWrappedNative.cpp
@@ -1387,7 +1387,7 @@ XPCWrappedNative::CallMethod(XPCCallContext& ccx,
 bool
 CallMethodHelper::Call()
 {
-    mCallContext.SetRetVal(JSVAL_VOID);
+    mCallContext.SetRetVal(JS::UndefinedValue());
 
     XPCJSRuntime::Get()->SetPendingException(nullptr);
 
@@ -1536,14 +1536,14 @@ CallMethodHelper::GetOutParamSource(uint8_t paramIndex, MutableHandleValue srcp)
     if (paramInfo.IsOut() && !paramInfo.IsRetval()) {
         MOZ_ASSERT(paramIndex < mArgc || paramInfo.IsOptional(),
                    "Expected either enough arguments or an optional argument");
-        jsval arg = paramIndex < mArgc ? mArgv[paramIndex] : JSVAL_NULL;
+        jsval arg = paramIndex < mArgc ? mArgv[paramIndex] : JS::NullValue();
         if (paramIndex < mArgc) {
             RootedObject obj(mCallContext);
             if (!arg.isPrimitive())
                 obj = &arg.toObject();
             if (!obj || !JS_GetPropertyById(mCallContext, obj, mIdxValueId, srcp)) {
                 // Explicitly passed in unusable value for out param.  Note
-                // that if i >= mArgc we already know that |arg| is JSVAL_NULL,
+                // that if i >= mArgc we already know that |arg| is JS::NullValue(),
                 // and that's ok.
                 ThrowBadParam(NS_ERROR_XPC_NEED_OUT_OBJECT, paramIndex,
                               mCallContext);
@@ -1807,7 +1807,7 @@ CallMethodHelper::ConvertIndependentParam(uint8_t i)
     // indirectly, regardless of in/out-ness.
     if (type_tag == nsXPTType::T_JSVAL) {
         // Root the value.
-        dp->val.j = JSVAL_VOID;
+        dp->val.j.setUndefined();
         if (!js::AddRawValueRoot(mCallContext, &dp->val.j, "XPCWrappedNative::CallMethod param"))
             return false;
     }
@@ -1841,9 +1841,9 @@ CallMethodHelper::ConvertIndependentParam(uint8_t i)
         if (i < mArgc)
             src = mArgv[i];
         else if (type_tag == nsXPTType::T_JSVAL)
-            src = JSVAL_VOID;
+            src.setUndefined();
         else
-            src = JSVAL_NULL;
+            src.setNull();
     }
 
     nsID param_iid;
@@ -1957,7 +1957,7 @@ CallMethodHelper::ConvertDependentParam(uint8_t i)
         // Handle the 'in' case.
         MOZ_ASSERT(i < mArgc || paramInfo.IsOptional(),
                      "Expected either enough arguments or an optional argument");
-        src = i < mArgc ? mArgv[i] : JSVAL_NULL;
+        src = i < mArgc ? mArgv[i] : JS::NullValue();
     }
 
     nsID param_iid;
diff --git a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
index efcf38d5cd17..71a5c94f5b68 100644
--- a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
@@ -479,7 +479,7 @@ XPC_WN_Shared_Convert(JSContext* cx, HandleObject obj, JSType type, MutableHandl
             vp.set(JS_GetNaNValue(cx));
             return true;
         case JSTYPE_BOOLEAN:
-            vp.set(JSVAL_TRUE);
+            vp.setBoolean(true);
             return true;
         case JSTYPE_VOID:
         case JSTYPE_STRING:
diff --git a/js/xpconnect/wrappers/XrayWrapper.cpp b/js/xpconnect/wrappers/XrayWrapper.cpp
index 9922a45b391d..8da20efffba8 100644
--- a/js/xpconnect/wrappers/XrayWrapper.cpp
+++ b/js/xpconnect/wrappers/XrayWrapper.cpp
@@ -1255,9 +1255,9 @@ XPCWrappedNativeXrayTraits::resolveNativeProperty(JSContext* cx, HandleObject wr
     desc.setAttributes(JSPROP_ENUMERATE);
     desc.setGetter(nullptr);
     desc.setSetter(nullptr);
-    desc.value().set(JSVAL_VOID);
+    desc.value().setUndefined();
 
-    RootedValue fval(cx, JSVAL_VOID);
+    RootedValue fval(cx, JS::UndefinedValue());
     if (member->IsConstant()) {
         if (!member->GetConstantValue(ccx, iface, desc.value().address())) {
             JS_ReportError(cx, "Failed to convert constant native property to JS value");
diff --git a/storage/mozStorageStatementJSHelper.cpp b/storage/mozStorageStatementJSHelper.cpp
index e3097a7ae939..9db095e55b19 100644
--- a/storage/mozStorageStatementJSHelper.cpp
+++ b/storage/mozStorageStatementJSHelper.cpp
@@ -61,7 +61,7 @@ stepFunc(JSContext *aCtx,
   bool hasMore = false;
   rv = stmt->ExecuteStep(&hasMore);
   if (NS_SUCCEEDED(rv) && !hasMore) {
-    *_vp = JSVAL_FALSE;
+    _vp->setBoolean(false);
     (void)stmt->Reset();
     return true;
   }
diff --git a/storage/mozStorageStatementRow.cpp b/storage/mozStorageStatementRow.cpp
index 4761ef2c7fd5..ee5409831c1a 100644
--- a/storage/mozStorageStatementRow.cpp
+++ b/storage/mozStorageStatementRow.cpp
@@ -102,7 +102,7 @@ StatementRow::GetProperty(nsIXPConnectWrappedNative *aWrapper,
       }
     }
     else if (type == mozIStorageValueArray::VALUE_TYPE_NULL) {
-      *_vp = JSVAL_NULL;
+      _vp->setNull();
     }
     else {
       NS_ERROR("unknown column type returned, what's going on?");
diff --git a/toolkit/devtools/server/nsJSInspector.cpp b/toolkit/devtools/server/nsJSInspector.cpp
index 46b283024935..59ae33d046d5 100644
--- a/toolkit/devtools/server/nsJSInspector.cpp
+++ b/toolkit/devtools/server/nsJSInspector.cpp
@@ -52,7 +52,7 @@ NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSInspector)
   NS_IMPL_CYCLE_COLLECTION_TRACE_JSVAL_MEMBER_CALLBACK(mLastRequestor)
 NS_IMPL_CYCLE_COLLECTION_TRACE_END
 
-nsJSInspector::nsJSInspector() : mNestedLoopLevel(0), mRequestors(1), mLastRequestor(JSVAL_NULL)
+nsJSInspector::nsJSInspector() : mNestedLoopLevel(0), mRequestors(1), mLastRequestor(JS::NullValue())
 {
 }
 
@@ -99,7 +99,7 @@ nsJSInspector::ExitNestedEventLoop(uint32_t *out)
     if (mNestedLoopLevel > 0)
       mLastRequestor = mRequestors.ElementAt(mNestedLoopLevel - 1);
     else
-      mLastRequestor = JSVAL_NULL;
+      mLastRequestor = JS::NullValue();
   } else {
     return NS_ERROR_FAILURE;
   }
diff --git a/xpcom/base/CycleCollectedJSRuntime.cpp b/xpcom/base/CycleCollectedJSRuntime.cpp
index ae9364006270..8df331ff987f 100644
--- a/xpcom/base/CycleCollectedJSRuntime.cpp
+++ b/xpcom/base/CycleCollectedJSRuntime.cpp
@@ -849,7 +849,7 @@ struct ClearJSHolder : TraceCallbacks
 {
   virtual void Trace(JS::Heap<JS::Value>* aPtr, const char*, void*) const override
   {
-    *aPtr = JSVAL_VOID;
+    aPtr->setUndefined();
   }
 
   virtual void Trace(JS::Heap<jsid>* aPtr, const char*, void*) const override
