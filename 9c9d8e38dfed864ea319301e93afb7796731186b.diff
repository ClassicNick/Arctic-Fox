diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
index fc0790609c0e7..42130b6dc6c4d 100644
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -33,7 +33,7 @@ interface nsIServiceWorkerInfo : nsISupports
   readonly attribute DOMString waitingCacheName;
 };
 
-[scriptable, builtinclass, uuid(679732e6-b655-42a2-a787-f43fa322d79d)]
+[scriptable, builtinclass, uuid(3cd3acce-8c80-4fcc-9265-067ebe8cab92)]
 interface nsIServiceWorkerManager : nsISupports
 {
   /**
@@ -123,6 +123,7 @@ interface nsIServiceWorkerManager : nsISupports
   nsIArray getAllRegistrations();
 
   void sendPushEvent(in ACString scope, in DOMString data);
+  void sendPushSubscriptionChangedEvent(in ACString scope);
 };
 
 %{ C++
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
index 53bd71720fcd5..914867004baa0 100644
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -370,4 +370,59 @@ NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(InstallEvent, ExtendableEvent, mActiveWorker)
 
+#ifndef MOZ_SIMPLEPUSH
+
+PushMessageData::PushMessageData(const nsAString& aData)
+  : mData(aData)
+{
+}
+
+PushMessageData::~PushMessageData()
+{
+}
+
+NS_IMPL_ISUPPORTS0(PushMessageData);
+
+
+void
+PushMessageData::Json(JSContext* cx, JS::MutableHandle<JSObject*> aRetval)
+{
+  //todo bug 1149195.  Don't be lazy.
+   NS_ABORT();
+}
+
+void
+PushMessageData::Text(nsAString& aData)
+{
+  aData = mData;
+}
+
+void
+PushMessageData::ArrayBuffer(JSContext* cx, JS::MutableHandle<JSObject*> aRetval)
+{
+  //todo bug 1149195.  Don't be lazy.
+   NS_ABORT();
+}
+
+mozilla::dom::File*
+PushMessageData::Blob()
+{
+  //todo bug 1149195.  Don't be lazy.
+  NS_ABORT();
+  return nullptr;
+}
+
+PushEvent::PushEvent(EventTarget* aOwner)
+  : ExtendableEvent(aOwner)
+{
+}
+
+NS_INTERFACE_MAP_BEGIN(PushEvent)
+NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
+
+NS_IMPL_ADDREF_INHERITED(PushEvent, ExtendableEvent)
+NS_IMPL_RELEASE_INHERITED(PushEvent, ExtendableEvent)
+
+#endif /* ! MOZ_SIMPLEPUSH */
+
 END_WORKERS_NAMESPACE
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
index fe48d2628077a..c6566f9dd58a5 100644
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -12,6 +12,12 @@
 #include "mozilla/dom/InstallEventBinding.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
+
+#ifndef MOZ_SIMPLEPUSH
+#include "mozilla/dom/PushEventBinding.h"
+#include "mozilla/dom/PushMessageDataBinding.h"
+#endif
+
 #include "nsProxyRelease.h"
 
 class nsIInterceptedChannel;
@@ -216,5 +222,91 @@ class InstallEvent final : public ExtendableEvent
   }
 };
 
+#ifndef MOZ_SIMPLEPUSH
+
+class PushMessageData final : public nsISupports,
+                              public nsWrapperCache
+{
+  nsString mData;
+
+public:
+  NS_DECL_ISUPPORTS
+
+  virtual JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override
+  {
+    return mozilla::dom::PushMessageDataBinding_workers::Wrap(aCx, this, aGivenProto);
+  }
+
+  nsISupports* GetParentObject() const {
+    return nullptr;
+  }
+
+  void Json(JSContext* cx, JS::MutableHandle<JSObject*> aRetval);
+  void Text(nsAString& aData);
+  void ArrayBuffer(JSContext* cx, JS::MutableHandle<JSObject*> aRetval);
+  mozilla::dom::File* Blob();
+
+  explicit PushMessageData(const nsAString& aData);
+private:
+  ~PushMessageData();
+
+};
+
+class PushEvent final : public ExtendableEvent
+{
+  nsString mData;
+  nsMainThreadPtrHandle<ServiceWorker> mServiceWorker;
+
+protected:
+  explicit PushEvent(mozilla::dom::EventTarget* aOwner);
+  ~PushEvent() {}
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_FORWARD_TO_EVENT
+
+  virtual JSObject* WrapObjectInternal(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override
+  {
+    return mozilla::dom::PushEventBinding_workers::Wrap(aCx, this, aGivenProto);
+  }
+
+  static already_AddRefed<PushEvent>
+  Constructor(mozilla::dom::EventTarget* aOwner,
+              const nsAString& aType,
+              const PushEventInit& aOptions)
+  {
+    nsRefPtr<PushEvent> e = new PushEvent(aOwner);
+    bool trusted = e->Init(aOwner);
+    e->InitEvent(aType, aOptions.mBubbles, aOptions.mCancelable);
+    e->SetTrusted(trusted);
+    if(aOptions.mData.WasPassed()){
+      e->mData = aOptions.mData.Value();
+    }
+    return e.forget();
+  }
+
+  static already_AddRefed<PushEvent>
+  Constructor(const GlobalObject& aGlobal,
+              const nsAString& aType,
+              const PushEventInit& aOptions,
+              ErrorResult& aRv)
+  {
+    nsCOMPtr<EventTarget> owner = do_QueryInterface(aGlobal.GetAsSupports());
+    return Constructor(owner, aType, aOptions);
+  }
+
+  void PostInit(nsMainThreadPtrHandle<ServiceWorker>& aServiceWorker)
+  {
+    mServiceWorker = aServiceWorker;
+  }
+
+  already_AddRefed<PushMessageData> Data()
+  {
+    nsRefPtr<PushMessageData> data = new PushMessageData(mData);
+    return data.forget();
+  }
+};
+#endif /* ! MOZ_SIMPLEPUSH */
+
 END_WORKERS_NAMESPACE
 #endif /* mozilla_dom_workers_serviceworkerevents_h__ */
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
index dc7f8096b76ee..82a89a1717856 100644
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1467,6 +1467,139 @@ class GetReadyPromiseRunnable : public nsRunnable
   }
 };
 
+#ifndef MOZ_SIMPLEPUSH
+
+class SendPushEventRunnable final : public WorkerRunnable
+{
+  nsString mData;
+  nsMainThreadPtrHandle<ServiceWorker> mServiceWorker;
+
+public:
+  SendPushEventRunnable(
+    WorkerPrivate* aWorkerPrivate,
+    const nsAString& aData,
+    nsMainThreadPtrHandle<ServiceWorker>& aServiceWorker)
+      : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+      , mData(aData)
+      , mServiceWorker(aServiceWorker)
+  {
+    AssertIsOnMainThread();
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    GlobalObject globalObj(aCx, aWorkerPrivate->GlobalScope()->GetWrapper());
+
+    PushEventInit pei;
+    pei.mData.Construct(mData);
+    pei.mBubbles = false;
+    pei.mCancelable = true;
+
+    ErrorResult result;
+    nsRefPtr<PushEvent> event =
+      PushEvent::Constructor(globalObj, NS_LITERAL_STRING("push"), pei, result);
+    if (NS_WARN_IF(result.Failed())) {
+      return false;
+    }
+
+    event->SetTrusted(true);
+    event->PostInit(mServiceWorker);
+
+    nsRefPtr<EventTarget> target = do_QueryObject(aWorkerPrivate->GlobalScope());
+    target->DispatchDOMEvent(nullptr, event, nullptr, nullptr);
+    return true;
+  }
+};
+
+class SendPushSubscriptionChangeEventRunnable final : public WorkerRunnable
+{
+  nsMainThreadPtrHandle<ServiceWorker> mServiceWorker;
+
+public:
+  SendPushSubscriptionChangeEventRunnable(
+    WorkerPrivate* aWorkerPrivate,
+    nsMainThreadPtrHandle<ServiceWorker>& aServiceWorker)
+      : WorkerRunnable(aWorkerPrivate, WorkerThreadModifyBusyCount)
+      , mServiceWorker(aServiceWorker)
+  {
+    AssertIsOnMainThread();
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+
+    nsRefPtr<EventTarget> target = do_QueryObject(aWorkerPrivate->GlobalScope());
+
+    nsContentUtils::DispatchTrustedEvent(nullptr, target,
+                                         NS_LITERAL_STRING("pushsubscriptionchange"),
+                                         true, true);
+    return true;
+  }
+};
+
+#endif /* ! MOZ_SIMPLEPUSH */
+
+NS_IMETHODIMP
+ServiceWorkerManager::SendPushEvent(const nsACString& aScope, const nsAString& aData)
+{
+#ifdef MOZ_SIMPLEPUSH
+  return NS_ERROR_NOT_AVAILABLE;
+#else
+  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+  if (!serviceWorker) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
+    new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
+
+  nsRefPtr<SendPushEventRunnable> r =
+    new SendPushEventRunnable(serviceWorker->GetWorkerPrivate(), aData, serviceWorkerHandle);
+
+  AutoJSAPI jsapi;
+  jsapi.Init();
+  if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+#endif
+}
+
+NS_IMETHODIMP
+ServiceWorkerManager::SendPushSubscriptionChangedEvent(const nsACString& aScope)
+{
+#ifdef MOZ_SIMPLEPUSH
+  return NS_ERROR_NOT_AVAILABLE;
+#else
+  nsRefPtr<ServiceWorker> serviceWorker = CreateServiceWorkerForScope(aScope);
+  if (!serviceWorker) {
+    return NS_ERROR_FAILURE;
+  }
+  nsMainThreadPtrHandle<ServiceWorker> serviceWorkerHandle(
+    new nsMainThreadPtrHolder<ServiceWorker>(serviceWorker));
+
+  nsRefPtr<SendPushSubscriptionChangeEventRunnable> r =
+    new SendPushSubscriptionChangeEventRunnable(serviceWorker->GetWorkerPrivate(), serviceWorkerHandle);
+
+  AutoJSAPI jsapi;
+  jsapi.Init();
+  if (NS_WARN_IF(!r->Dispatch(jsapi.cx()))) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+#endif
+}
+
 NS_IMETHODIMP
 ServiceWorkerManager::GetReadyPromise(nsIDOMWindow* aWindow,
                                       nsISupports** aPromise)
@@ -1568,6 +1701,37 @@ ServiceWorkerManager::CheckReadyPromise(nsPIDOMWindow* aWindow,
   return false;
 }
 
+already_AddRefed<ServiceWorker>
+ServiceWorkerManager::CreateServiceWorkerForScope(const nsACString& aScope)
+{
+  AssertIsOnMainThread();
+
+  nsCOMPtr<nsIURI> scopeURI;
+  nsresult rv = NS_NewURI(getter_AddRefs(scopeURI), aScope, nullptr, nullptr);
+  if (NS_FAILED(rv)) {
+    return nullptr;
+  }
+  nsRefPtr<ServiceWorkerRegistrationInfo> registration = GetServiceWorkerRegistrationInfo(scopeURI);
+  if (!registration) {
+    return nullptr;
+  }
+
+  if (!registration->mActiveWorker) {
+    return nullptr;
+  }
+
+  nsRefPtr<ServiceWorker> sw;
+  rv = CreateServiceWorker(registration->mPrincipal,
+                           registration->mActiveWorker,
+                           getter_AddRefs(sw));
+
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return nullptr;
+  }
+
+  return sw.forget();
+}
+
 class ServiceWorkerUnregisterJob final : public ServiceWorkerJob
 {
   nsRefPtr<ServiceWorkerRegistrationInfo> mRegistration;
@@ -2318,9 +2482,9 @@ class FetchEventRunnable : public WorkerRunnable
     nsRefPtr<InternalHeaders> internalHeaders = new InternalHeaders(HeadersGuardEnum::Request);
     MOZ_ASSERT(mHeaderNames.Length() == mHeaderValues.Length());
     for (uint32_t i = 0; i < mHeaderNames.Length(); i++) {
-      ErrorResult rv;
-      internalHeaders->Set(mHeaderNames[i], mHeaderValues[i], rv);
-      if (NS_WARN_IF(rv.Failed())) {
+      ErrorResult result;
+      internalHeaders->Set(mHeaderNames[i], mHeaderValues[i], result);
+      if (NS_WARN_IF(result.Failed())) {
         return false;
       }
     }
@@ -2334,9 +2498,9 @@ class FetchEventRunnable : public WorkerRunnable
     reqInit.mMode.Construct(mRequestMode);
     reqInit.mCredentials.Construct(mRequestCredentials);
 
-    ErrorResult rv;
-    nsRefPtr<Request> request = Request::Constructor(globalObj, requestInfo, reqInit, rv);
-    if (NS_WARN_IF(rv.Failed())) {
+    ErrorResult result;
+    nsRefPtr<Request> request = Request::Constructor(globalObj, requestInfo, reqInit, result);
+    if (NS_WARN_IF(result.Failed())) {
       return false;
     }
     // For Telemetry, note that this Request object was created by a Fetch event.
@@ -2353,8 +2517,8 @@ class FetchEventRunnable : public WorkerRunnable
     init.mCancelable = true;
     init.mIsReload.Construct(mIsReload);
     nsRefPtr<FetchEvent> event =
-      FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, rv);
-    if (NS_WARN_IF(rv.Failed())) {
+      FetchEvent::Constructor(globalObj, NS_LITERAL_STRING("fetch"), init, result);
+    if (NS_WARN_IF(result.Failed())) {
       return false;
     }
 
diff --git a/dom/workers/ServiceWorkerManager.h b/dom/workers/ServiceWorkerManager.h
index 6088134830e63..fe9627e53fd38 100644
--- a/dom/workers/ServiceWorkerManager.h
+++ b/dom/workers/ServiceWorkerManager.h
@@ -427,6 +427,9 @@ class ServiceWorkerManager final
                            WhichServiceWorker aWhichWorker,
                            nsISupports** aServiceWorker);
 
+  already_AddRefed<ServiceWorker>
+  CreateServiceWorkerForScope(const nsACString& aScope);
+
   void
   InvalidateServiceWorkerRegistrationWorker(ServiceWorkerRegistrationInfo* aRegistration,
                                             WhichServiceWorker aWhichOnes);
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
index e5a67ee43e3f6..dd8656f54efd4 100644
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -19,6 +19,10 @@
 #include "nsISupportsPrimitives.h"
 #include "nsPIDOMWindow.h"
 
+#ifndef MOZ_SIMPLEPUSH
+#include "mozilla/dom/PushManagerBinding.h"
+#endif
+
 using namespace mozilla::dom::workers;
 
 namespace mozilla {
@@ -30,12 +34,24 @@ NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
+#ifdef MOZ_SIMPLEPUSH
+
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistration,
                                    DOMEventTargetHelper,
                                    mInstallingWorker,
                                    mWaitingWorker,
                                    mActiveWorker)
 
+#else
+
+NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistration,
+                                   DOMEventTargetHelper,
+                                   mInstallingWorker,
+                                   mWaitingWorker,
+                                   mActiveWorker,
+                                   mPushManager)
+#endif
+
 ServiceWorkerRegistration::ServiceWorkerRegistration(nsPIDOMWindow* aWindow,
                                                      const nsAString& aScope)
   : DOMEventTargetHelper(aWindow)
@@ -291,5 +307,55 @@ ServiceWorkerRegistration::StopListeningForEvents()
   }
 }
 
+already_AddRefed<PushManager>
+ServiceWorkerRegistration::GetPushManager(ErrorResult& aRv)
+{
+  AssertIsOnMainThread();
+
+#ifdef MOZ_SIMPLEPUSH
+  return nullptr;
+#else
+
+  if (!mPushManager) {
+    nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
+
+    if (!globalObject) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    AutoJSAPI jsapi;
+    if (NS_WARN_IF(!jsapi.Init(globalObject))) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    JSContext* cx = jsapi.cx();
+
+    JS::RootedObject globalJs(cx, globalObject->GetGlobalJSObject());
+    GlobalObject global(cx, globalJs);
+
+    // TODO: bug 1148117.  This will fail when swr is exposed on workers
+    JS::Rooted<JSObject*> jsImplObj(cx);
+    nsCOMPtr<nsIGlobalObject> unused = ConstructJSImplementation(cx, "@mozilla.org/push/PushManager;1",
+                              global, &jsImplObj, aRv);
+    if (aRv.Failed()) {
+      return nullptr;
+    }
+    mPushManager = new PushManager(jsImplObj, globalObject);
+
+    mPushManager->SetScope(mScope, aRv);
+    if (aRv.Failed()) {
+      mPushManager = nullptr;
+      return nullptr;
+    }
+  }
+
+  nsRefPtr<PushManager> ret = mPushManager;
+  return ret.forget();
+
+  #endif /* ! MOZ_SIMPLEPUSH */
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/workers/ServiceWorkerRegistration.h b/dom/workers/ServiceWorkerRegistration.h
index 694687f74e041..f3222300fa6b1 100644
--- a/dom/workers/ServiceWorkerRegistration.h
+++ b/dom/workers/ServiceWorkerRegistration.h
@@ -17,6 +17,7 @@ namespace mozilla {
 namespace dom {
 
 class Promise;
+class PushManager;
 
 namespace workers {
 class ServiceWorker;
@@ -62,6 +63,16 @@ class ServiceWorkerRegistration final : public DOMEventTargetHelper
   // DOMEventTargethelper
   virtual void DisconnectFromOwner() override;
 
+  already_AddRefed<PushManager>
+  GetPushManager(ErrorResult& aRv);
+
+  // Something that we can feed into the Func webidl property to ensure that
+  // SetScope is never exposed to the user.
+  static bool
+  WebPushMethodHider(JSContext* unusedContext, JSObject* unusedObject) {
+    return false;
+  }
+
 private:
   ~ServiceWorkerRegistration();
 
@@ -82,6 +93,10 @@ class ServiceWorkerRegistration final : public DOMEventTargetHelper
   nsRefPtr<workers::ServiceWorker> mWaitingWorker;
   nsRefPtr<workers::ServiceWorker> mActiveWorker;
 
+#ifndef MOZ_SIMPLEPUSH
+  nsRefPtr<PushManager> mPushManager;
+#endif
+
   const nsString mScope;
   bool mListeningForEvents;
 };
@@ -89,4 +104,4 @@ class ServiceWorkerRegistration final : public DOMEventTargetHelper
 } // namespace dom
 } // namespace mozilla
 
-#endif /* mozilla_dom_ServiceWorkerRegistration_h */
+#endif /* mozilla_dom_ServiceWorkerRegistration_h */
\ No newline at end of file
