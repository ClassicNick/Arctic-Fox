diff --git a/dom/base/Crypto.cpp b/dom/base/Crypto.cpp
index a260b58c21f1..8a93789a19c6 100644
--- a/dom/base/Crypto.cpp
+++ b/dom/base/Crypto.cpp
@@ -110,7 +110,7 @@ Crypto::GetRandomValues(JSContext* aCx, const ArrayBufferView& aArray,
     }
 
     memcpy(data, buf, dataLen);
-    NS_Free(buf);
+    free(buf);
   }
 
   aRetval.set(view);
diff --git a/dom/fetch/Fetch.cpp b/dom/fetch/Fetch.cpp
index 0e66279d6e12..f681d2126cb6 100644
--- a/dom/fetch/Fetch.cpp
+++ b/dom/fetch/Fetch.cpp
@@ -758,7 +758,7 @@ class MOZ_STACK_CLASS FormDataParser
       // Unfortunately we've to copy the data first since all our strings are
       // going to free it. We also need fallible alloc, so we can't just use
       // ToNewCString().
-      char* copy = static_cast<char*>(NS_Alloc(body.Length()));
+      char* copy = static_cast<char*>(moz_xmalloc(body.Length()));
       if (!copy) {
         NS_WARNING("Failed to copy File entry body.");
         return false;
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
index 5df38c2e3edf..d9f69ab4d60e 100644
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -2323,7 +2323,7 @@ HTMLInputElement::MozGetFileNameArray(uint32_t* aLength, char16_t*** aFileNames)
 
   *aLength = array.Length();
   char16_t** ret =
-    static_cast<char16_t**>(NS_Alloc(*aLength * sizeof(char16_t*)));
+    static_cast<char16_t**>(moz_xmalloc(*aLength * sizeof(char16_t*)));
   if (!ret) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
diff --git a/dom/html/UndoManager.cpp b/dom/html/UndoManager.cpp
index 610ce2b3cbe6..31dcdbc14ee0 100644
--- a/dom/html/UndoManager.cpp
+++ b/dom/html/UndoManager.cpp
@@ -1028,7 +1028,7 @@ UndoManager::ItemInternal(uint32_t aIndex,
     aItems.AppendElement(static_cast<DOMTransaction*>(listData[i]));
     NS_RELEASE(listData[i]);
   }
-  NS_Free(listData);
+  free(listData);
 }
 
 void
diff --git a/dom/indexedDB/ActorsParent.cpp b/dom/indexedDB/ActorsParent.cpp
index 129cf1c1220f..ccaa4b6cd92d 100644
--- a/dom/indexedDB/ActorsParent.cpp
+++ b/dom/indexedDB/ActorsParent.cpp
@@ -21268,8 +21268,6 @@ ObjectStoreAddOrPutRequestOp::DoDatabaseWork(DatabaseConnection* aConnection)
   {
     size_t compressedLength = snappy::MaxCompressedLength(uncompressedLength);
 
-    // malloc is equivalent to NS_Alloc, which we use because mozStorage
-    // expects to be able to free the adopted pointer with NS_Free.
     char* compressed = static_cast<char*>(malloc(compressedLength));
     if (NS_WARN_IF(!compressed)) {
       return NS_ERROR_OUT_OF_MEMORY;
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index 7a0a5aa358e1..0ee9ba4e0e9a 100755
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -4049,7 +4049,7 @@ ContentParent::RecvGetRandomValues(const uint32_t& length,
 
     memcpy(randomValues->Elements(), buf, length);
 
-    NS_Free(buf);
+    free(buf);
 
     return true;
 }
diff --git a/dom/json/nsJSON.cpp b/dom/json/nsJSON.cpp
index 5aab45bae119..afa881243725 100644
--- a/dom/json/nsJSON.cpp
+++ b/dom/json/nsJSON.cpp
@@ -344,7 +344,7 @@ nsJSONWriter::WriteToStream(nsIOutputStream *aStream,
   NS_ENSURE_SUCCESS(rv, rv);
 
   // create the buffer we need
-  char* destBuf = (char *) NS_Alloc(aDestLength);
+  char* destBuf = (char *) moz_xmalloc(aDestLength);
   if (!destBuf)
     return NS_ERROR_OUT_OF_MEMORY;
 
@@ -352,7 +352,7 @@ nsJSONWriter::WriteToStream(nsIOutputStream *aStream,
   if (NS_SUCCEEDED(rv))
     rv = aStream->Write(destBuf, aDestLength, &bytesWritten);
 
-  NS_Free(destBuf);
+  free(destBuf);
   mDidWrite = true;
 
   return rv;
diff --git a/dom/media/MediaDevices.cpp b/dom/media/MediaDevices.cpp
index 2d2e01541f25..e13292c14a99 100644
--- a/dom/media/MediaDevices.cpp
+++ b/dom/media/MediaDevices.cpp
@@ -97,7 +97,7 @@ class MediaDevices::EnumDevResolver : public nsIGetUserMediaDevicesSuccessCallba
       NS_ENSURE_SUCCESS(rv, rv);
 
       if (elementType != nsIDataType::VTYPE_INTERFACE) {
-        NS_Free(rawArray);
+        free(rawArray);
         return NS_ERROR_FAILURE;
       }
 
@@ -107,7 +107,7 @@ class MediaDevices::EnumDevResolver : public nsIGetUserMediaDevicesSuccessCallba
         devices.AppendElement(device);
         NS_IF_RELEASE(supportsArray[i]); // explicitly decrease refcount for rawptr
       }
-      NS_Free(rawArray); // explicitly free memory from nsIVariant::GetAsArray
+      free(rawArray); // explicitly free memory from nsIVariant::GetAsArray
     }
     nsTArray<nsRefPtr<MediaDeviceInfo>> infos;
     for (auto& device : devices) {
diff --git a/dom/media/MediaPermissionGonk.cpp b/dom/media/MediaPermissionGonk.cpp
index b93188f7e3bd..b54602c7b0b8 100644
--- a/dom/media/MediaPermissionGonk.cpp
+++ b/dom/media/MediaPermissionGonk.cpp
@@ -357,7 +357,7 @@ MediaDeviceSuccessCallback::OnSuccess(nsIVariant* aDevices)
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (elementType != nsIDataType::VTYPE_INTERFACE) {
-    NS_Free(rawArray);
+    free(rawArray);
     return NS_ERROR_FAILURE;
   }
 
@@ -370,7 +370,7 @@ MediaDeviceSuccessCallback::OnSuccess(nsIVariant* aDevices)
     devices.AppendElement(device);
     NS_IF_RELEASE(supportsArray[i]); // explicitly decrease reference count for raw pointer
   }
-  NS_Free(rawArray); // explicitly free for the memory from nsIVariant::GetAsArray
+  free(rawArray); // explicitly free for the memory from nsIVariant::GetAsArray
 
   // Send MediaPermissionRequest
   nsRefPtr<MediaPermissionRequest> req = new MediaPermissionRequest(mRequest, devices);
diff --git a/dom/media/VideoUtils.cpp b/dom/media/VideoUtils.cpp
index 27c7075deb0e..4637a22c418b 100644
--- a/dom/media/VideoUtils.cpp
+++ b/dom/media/VideoUtils.cpp
@@ -280,7 +280,7 @@ GenerateRandomName(nsCString& aOutSalt, uint32_t aLength)
   nsDependentCSubstring randomData(reinterpret_cast<const char*>(buffer),
                                    requiredBytesLength);
   rv = Base64Encode(randomData, temp);
-  NS_Free(buffer);
+  free(buffer);
   buffer = nullptr;
   if (NS_FAILED (rv)) return rv;
 
diff --git a/dom/plugins/base/PluginPRLibrary.cpp b/dom/plugins/base/PluginPRLibrary.cpp
index 00c756f51834..313276161faa 100644
--- a/dom/plugins/base/PluginPRLibrary.cpp
+++ b/dom/plugins/base/PluginPRLibrary.cpp
@@ -243,10 +243,10 @@ PluginPRLibrary::NPP_GetSitesWithData(InfallibleTArray<nsCString>& result)
   char** iterator = sites;
   while (*iterator) {
     result.AppendElement(*iterator);
-    NS_Free(*iterator);
+    free(*iterator);
     ++iterator;
   }
-  NS_Free(sites);
+  free(sites);
 
   return NS_OK;
 }
diff --git a/dom/plugins/base/nsNPAPIPlugin.cpp b/dom/plugins/base/nsNPAPIPlugin.cpp
index 50bd786e112a..bd8ec6c4e843 100644
--- a/dom/plugins/base/nsNPAPIPlugin.cpp
+++ b/dom/plugins/base/nsNPAPIPlugin.cpp
@@ -1848,7 +1848,7 @@ _releasevariantvalue(NPVariant* variant)
           }
         }
 #else
-        NS_Free((void *)s->UTF8Characters);
+        free((void *)s->UTF8Characters);
 #endif
       }
       break;
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.cpp b/dom/plugins/base/nsNPAPIPluginInstance.cpp
index efcc353682e5..c421c480acfe 100644
--- a/dom/plugins/base/nsNPAPIPluginInstance.cpp
+++ b/dom/plugins/base/nsNPAPIPluginInstance.cpp
@@ -230,19 +230,19 @@ nsNPAPIPluginInstance::~nsNPAPIPluginInstance()
 
   for (uint32_t i = 0; i < mCachedParamLength; i++) {
     if (mCachedParamNames[i]) {
-      NS_Free(mCachedParamNames[i]);
+      free(mCachedParamNames[i]);
       mCachedParamNames[i] = nullptr;
     }
     if (mCachedParamValues[i]) {
-      NS_Free(mCachedParamValues[i]);
+      free(mCachedParamValues[i]);
       mCachedParamValues[i] = nullptr;
     }
   }
 
-  NS_Free(mCachedParamNames);
+  free(mCachedParamNames);
   mCachedParamNames = nullptr;
 
-  NS_Free(mCachedParamValues);
+  free(mCachedParamValues);
   mCachedParamValues = nullptr;
 }
 
@@ -454,8 +454,8 @@ nsNPAPIPluginInstance::Start()
   uint32_t quirkParamLength = params.Length() ?
                                 mCachedParamLength : attributes.Length();
 
-  mCachedParamNames = (char**)NS_Alloc(sizeof(char*) * mCachedParamLength);
-  mCachedParamValues = (char**)NS_Alloc(sizeof(char*) * mCachedParamLength);
+  mCachedParamNames = (char**)moz_xmalloc(sizeof(char*) * mCachedParamLength);
+  mCachedParamValues = (char**)moz_xmalloc(sizeof(char*) * mCachedParamLength);
 
   for (uint32_t i = 0; i < attributes.Length(); i++) {
     mCachedParamNames[i] = ToNewUTF8String(attributes[i].mName);
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
index dcf8c794ad41..ac9854448c77 100644
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -557,7 +557,7 @@ nsresult nsPluginHost::PostURL(nsISupports* pluginInst,
 
     nsCOMPtr<nsIStringInputStream> sis = do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
     if (!sis) {
-      NS_Free(dataToPost);
+      free(dataToPost);
       return rv;
     }
 
diff --git a/dom/plugins/base/nsPluginsDirDarwin.cpp b/dom/plugins/base/nsPluginsDirDarwin.cpp
index 6b789a3abc38..bd317a43cde3 100644
--- a/dom/plugins/base/nsPluginsDirDarwin.cpp
+++ b/dom/plugins/base/nsPluginsDirDarwin.cpp
@@ -104,19 +104,19 @@ static char* CFStringRefToUTF8Buffer(CFStringRef cfString)
   int bufferLength =
     ::CFStringGetMaximumSizeForEncoding(::CFStringGetLength(cfString),
                                         kCFStringEncodingUTF8) + 1;
-  char* newBuffer = static_cast<char*>(NS_Alloc(bufferLength));
+  char* newBuffer = static_cast<char*>(moz_xmalloc(bufferLength));
   if (!newBuffer) {
     return nullptr;
   }
 
   if (!::CFStringGetCString(cfString, newBuffer, bufferLength,
                             kCFStringEncodingUTF8)) {
-    NS_Free(newBuffer);
+    free(newBuffer);
     return nullptr;
   }
 
-  newBuffer = static_cast<char*>(NS_Realloc(newBuffer,
-                                            strlen(newBuffer) + 1));
+  newBuffer = static_cast<char*>(moz_xrealloc(newBuffer,
+                                              strlen(newBuffer) + 1));
   return newBuffer;
 }
 
@@ -224,15 +224,15 @@ static void ParsePlistPluginInfo(nsPluginInfo& info, CFBundleRef bundle)
 
   // Allocate memory for mime data
   int mimeDataArraySize = mimeDictKeyCount * sizeof(char*);
-  info.fMimeTypeArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
+  info.fMimeTypeArray = static_cast<char**>(moz_xmalloc(mimeDataArraySize));
   if (!info.fMimeTypeArray)
     return;
   memset(info.fMimeTypeArray, 0, mimeDataArraySize);
-  info.fExtensionArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
+  info.fExtensionArray = static_cast<char**>(moz_xmalloc(mimeDataArraySize));
   if (!info.fExtensionArray)
     return;
   memset(info.fExtensionArray, 0, mimeDataArraySize);
-  info.fMimeDescriptionArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
+  info.fMimeDescriptionArray = static_cast<char**>(moz_xmalloc(mimeDataArraySize));
   if (!info.fMimeDescriptionArray)
     return;
   memset(info.fMimeDescriptionArray, 0, mimeDataArraySize);
@@ -350,7 +350,7 @@ nsresult nsPluginFile::LoadPlugin(PRLibrary **outLibrary)
 static char* p2cstrdup(StringPtr pstr)
 {
   int len = pstr[0];
-  char* cstr = static_cast<char*>(NS_Alloc(len + 1));
+  char* cstr = static_cast<char*>(moz_xmalloc(len + 1));
   if (cstr) {
     memmove(cstr, pstr + 1, len);
     cstr[len] = '\0';
@@ -540,14 +540,14 @@ nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info, PRLibrary **outLibrary)
 
   // Fill in the info struct based on the data in the BPSupportedMIMETypes struct
   int variantCount = info.fVariantCount;
-  info.fMimeTypeArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+  info.fMimeTypeArray = static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
   if (!info.fMimeTypeArray)
     return NS_ERROR_OUT_OF_MEMORY;
-  info.fExtensionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+  info.fExtensionArray = static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
   if (!info.fExtensionArray)
     return NS_ERROR_OUT_OF_MEMORY;
   if (mi.infoStrings) {
-    info.fMimeDescriptionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
+    info.fMimeDescriptionArray = static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
     if (!info.fMimeDescriptionArray)
       return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -572,20 +572,20 @@ nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info, PRLibrary **outLibrary)
 
 nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
 {
-  NS_Free(info.fName);
-  NS_Free(info.fDescription);
+  free(info.fName);
+  free(info.fDescription);
   int variantCount = info.fVariantCount;
   for (int i = 0; i < variantCount; i++) {
-    NS_Free(info.fMimeTypeArray[i]);
-    NS_Free(info.fExtensionArray[i]);
-    NS_Free(info.fMimeDescriptionArray[i]);
-  }
-  NS_Free(info.fMimeTypeArray);
-  NS_Free(info.fMimeDescriptionArray);
-  NS_Free(info.fExtensionArray);
-  NS_Free(info.fFileName);
-  NS_Free(info.fFullPath);
-  NS_Free(info.fVersion);
+    free(info.fMimeTypeArray[i]);
+    free(info.fExtensionArray[i]);
+    free(info.fMimeDescriptionArray[i]);
+  }
+  free(info.fMimeTypeArray);
+  free(info.fMimeDescriptionArray);
+  free(info.fExtensionArray);
+  free(info.fFileName);
+  free(info.fFullPath);
+  free(info.fVersion);
 
   return NS_OK;
 }
diff --git a/dom/plugins/ipc/PluginModuleChild.cpp b/dom/plugins/ipc/PluginModuleChild.cpp
index 513cddf01219..54d1ef226634 100644
--- a/dom/plugins/ipc/PluginModuleChild.cpp
+++ b/dom/plugins/ipc/PluginModuleChild.cpp
@@ -752,10 +752,10 @@ PluginModuleChild::AnswerNPP_GetSitesWithData(InfallibleTArray<nsCString>* aResu
     char** iterator = result;
     while (*iterator) {
         aResult->AppendElement(*iterator);
-        NS_Free(*iterator);
+        free(*iterator);
         ++iterator;
     }
-    NS_Free(result);
+    free(result);
 
     return true;
 }
@@ -1330,7 +1330,7 @@ _memfree(void* aPtr)
     PLUGIN_LOG_DEBUG_FUNCTION;
     // Only assert plugin thread here for consistency with in-process plugins.
     AssertPluginThread();
-    NS_Free(aPtr);
+    free(aPtr);
 }
 
 uint32_t
@@ -1399,7 +1399,7 @@ _memalloc(uint32_t aSize)
     PLUGIN_LOG_DEBUG_FUNCTION;
     // Only assert plugin thread here for consistency with in-process plugins.
     AssertPluginThread();
-    return NS_Alloc(aSize);
+    return moz_xmalloc(aSize);
 }
 
 // Deprecated entry points for the old Java plugin.
diff --git a/dom/tv/FakeTVService.cpp b/dom/tv/FakeTVService.cpp
index 1137b58f8142..298a37be0fd1 100644
--- a/dom/tv/FakeTVService.cpp
+++ b/dom/tv/FakeTVService.cpp
@@ -200,7 +200,7 @@ class EITBroadcastedCallback final : public nsITimerCallback
   {
     // Notify mock EIT broadcasting.
     nsITVProgramData** programDataList =
-      static_cast<nsITVProgramData **>(NS_Alloc(1 * sizeof(nsITVProgramData*)));
+      static_cast<nsITVProgramData **>(moz_xmalloc(1 * sizeof(nsITVProgramData*)));
     programDataList[0] = new TVProgramData();
     programDataList[0]->SetEventId(NS_LITERAL_STRING("eventId"));
     programDataList[0]->SetTitle(NS_LITERAL_STRING("title"));
diff --git a/dom/tv/TVTypes.cpp b/dom/tv/TVTypes.cpp
index bd5c103fabaa..304536355737 100644
--- a/dom/tv/TVTypes.cpp
+++ b/dom/tv/TVTypes.cpp
@@ -55,7 +55,7 @@ TVTunerData::GetSupportedSourceTypes(uint32_t* aCount,
   *aCount = mCount;
 
   char** sourceTypes = (mCount > 0) ?
-                       static_cast<char **>(NS_Alloc(mCount * sizeof(char*))) :
+                       static_cast<char **>(moz_xmalloc(mCount * sizeof(char*))) :
                        nullptr;
   for (uint32_t i = 0; i < mCount; i++) {
     sourceTypes[i] = NS_strdup(mSupportedSourceTypes[i]);
@@ -87,7 +87,7 @@ TVTunerData::SetSupportedSourceTypes(uint32_t aCount,
   mCount = aCount;
 
   mSupportedSourceTypes = (mCount > 0) ?
-                          static_cast<char **>(NS_Alloc(mCount * sizeof(char*))) :
+                          static_cast<char **>(moz_xmalloc(mCount * sizeof(char*))) :
                           nullptr;
   for (uint32_t i = 0; i < mCount; i++) {
     mSupportedSourceTypes[i] = NS_strdup(aSourceTypes[i]);
@@ -377,7 +377,7 @@ TVProgramData::GetAudioLanguages(uint32_t* aCount,
   *aCount = mAudioLanguageCount;
 
   char** languages = (mAudioLanguageCount > 0) ?
-                     static_cast<char **>(NS_Alloc(mAudioLanguageCount * sizeof(char*))) :
+                     static_cast<char **>(moz_xmalloc(mAudioLanguageCount * sizeof(char*))) :
                      nullptr;
   for (uint32_t i = 0; i < mAudioLanguageCount; i++) {
     languages[i] = NS_strdup(mAudioLanguages[i]);
@@ -402,7 +402,7 @@ TVProgramData::SetAudioLanguages(uint32_t aCount,
   mAudioLanguageCount = aCount;
 
   mAudioLanguages = (mAudioLanguageCount > 0) ?
-                    static_cast<char **>(NS_Alloc(mAudioLanguageCount * sizeof(char*))) :
+                    static_cast<char **>(moz_xmalloc(mAudioLanguageCount * sizeof(char*))) :
                     nullptr;
   for (uint32_t i = 0; i < mAudioLanguageCount; i++) {
     mAudioLanguages[i] = NS_strdup(aLanguages[i]);
@@ -418,7 +418,7 @@ TVProgramData::GetSubtitleLanguages(uint32_t* aCount,
   *aCount = mSubtitleLanguageCount;
 
   char** languages = (mSubtitleLanguageCount > 0) ?
-                     static_cast<char **>(NS_Alloc(mSubtitleLanguageCount * sizeof(char*))) :
+                     static_cast<char **>(moz_xmalloc(mSubtitleLanguageCount * sizeof(char*))) :
                      nullptr;
   for (uint32_t i = 0; i < mSubtitleLanguageCount; i++) {
     languages[i] = NS_strdup(mSubtitleLanguages[i]);
@@ -443,7 +443,7 @@ TVProgramData::SetSubtitleLanguages(uint32_t aCount,
   mSubtitleLanguageCount = aCount;
 
   mSubtitleLanguages = (mSubtitleLanguageCount > 0) ?
-                       static_cast<char **>(NS_Alloc(mSubtitleLanguageCount * sizeof(char*))) :
+                       static_cast<char **>(moz_xmalloc(mSubtitleLanguageCount * sizeof(char*))) :
                        nullptr;
   for (uint32_t i = 0; i < mSubtitleLanguageCount; i++) {
     mSubtitleLanguages[i] = NS_strdup(aLanguages[i]);
diff --git a/dom/xbl/nsXBLProtoImplField.cpp b/dom/xbl/nsXBLProtoImplField.cpp
index cd106b447933..3be74e51b460 100644
--- a/dom/xbl/nsXBLProtoImplField.cpp
+++ b/dom/xbl/nsXBLProtoImplField.cpp
@@ -63,7 +63,7 @@ nsXBLProtoImplField::~nsXBLProtoImplField()
   MOZ_COUNT_DTOR(nsXBLProtoImplField);
   if (mFieldText)
     free(mFieldText);
-  NS_Free(mName);
+  free(mName);
   NS_CONTENT_DELETE_LIST_MEMBER(nsXBLProtoImplField, this, mNext);
 }
 
diff --git a/editor/libeditor/ChangeStyleTxn.cpp b/editor/libeditor/ChangeStyleTxn.cpp
index 66b308ad7dc3..4305ad1db831 100644
--- a/editor/libeditor/ChangeStyleTxn.cpp
+++ b/editor/libeditor/ChangeStyleTxn.cpp
@@ -17,7 +17,6 @@
 #include "nsReadableUtils.h"            // for ToNewUnicode
 #include "nsString.h"                   // for nsAutoString, nsString, etc
 #include "nsUnicharUtils.h"             // for nsCaseInsensitiveStringComparator
-#include "nsXPCOM.h"                    // for NS_Free
 
 using namespace mozilla;
 using namespace mozilla::dom;
@@ -75,7 +74,7 @@ ChangeStyleTxn::ValueIncludes(const nsAString &aValueList,
     }
     start = ++end;
   }
-  NS_Free(value);
+  free(value);
   return result;
 }
 
diff --git a/editor/libeditor/nsHTMLDataTransfer.cpp b/editor/libeditor/nsHTMLDataTransfer.cpp
index cdf545c55a80..c33e6eb57dc8 100644
--- a/editor/libeditor/nsHTMLDataTransfer.cpp
+++ b/editor/libeditor/nsHTMLDataTransfer.cpp
@@ -1632,7 +1632,7 @@ NS_IMETHODIMP nsHTMLEditor::PasteAsPlaintextQuotation(int32_t aSelectionType)
       rv = InsertAsPlaintextQuotation(stuffToPaste, true, 0);
     }
   }
-  NS_Free(flav);
+  free(flav);
 
   return rv;
 }
diff --git a/editor/libeditor/nsHTMLEditor.cpp b/editor/libeditor/nsHTMLEditor.cpp
index 5e4c823a3499..268a48a34b0e 100644
--- a/editor/libeditor/nsHTMLEditor.cpp
+++ b/editor/libeditor/nsHTMLEditor.cpp
@@ -728,7 +728,7 @@ AssertParserServiceIsCorrect(nsIAtom* aTag, bool aIsBlock)
       assertmsg.Append(tagName);
       char* assertstr = ToNewCString(assertmsg);
       NS_ASSERTION(aIsBlock, assertstr);
-      NS_Free(assertstr);
+      free(assertstr);
     }
   }
 #endif // DEBUG
diff --git a/editor/libeditor/nsPlaintextDataTransfer.cpp b/editor/libeditor/nsPlaintextDataTransfer.cpp
index 9984f075d5be..d7b3d5a9bec2 100644
--- a/editor/libeditor/nsPlaintextDataTransfer.cpp
+++ b/editor/libeditor/nsPlaintextDataTransfer.cpp
@@ -127,7 +127,7 @@ NS_IMETHODIMP nsPlaintextEditor::InsertTextFromTransferable(nsITransferable *aTr
       rv = InsertTextAt(stuffToPaste, aDestinationNode, aDestOffset, aDoDeleteSelection);
     }
   }
-  NS_Free(bestFlavor);
+  free(bestFlavor);
       
   // Try to scroll the selection into view if the paste/drop succeeded
 
diff --git a/editor/libeditor/nsPlaintextEditor.cpp b/editor/libeditor/nsPlaintextEditor.cpp
index b4ad3ef89189..7533eb3cca64 100644
--- a/editor/libeditor/nsPlaintextEditor.cpp
+++ b/editor/libeditor/nsPlaintextEditor.cpp
@@ -1390,7 +1390,7 @@ nsPlaintextEditor::PasteAsQuotation(int32_t aSelectionType)
         rv = InsertAsQuotation(stuffToPaste, 0);
       }
     }
-    NS_Free(flav);
+    free(flav);
   }
 
   return rv;
diff --git a/editor/txmgr/nsTransactionList.cpp b/editor/txmgr/nsTransactionList.cpp
index 57c0a5b2a47c..a960df92a85b 100644
--- a/editor/txmgr/nsTransactionList.cpp
+++ b/editor/txmgr/nsTransactionList.cpp
@@ -110,7 +110,7 @@ NS_IMETHODIMP nsTransactionList::GetData(int32_t aIndex,
 
   nsCOMArray<nsISupports>& data = item->GetData();
 
-  nsISupports** ret = static_cast<nsISupports**>(NS_Alloc(data.Count() *
+  nsISupports** ret = static_cast<nsISupports**>(moz_xmalloc(data.Count() *
     sizeof(nsISupports*)));
 
   for (int32_t i = 0; i < data.Count(); i++) {
diff --git a/embedding/components/commandhandler/nsControllerCommandTable.cpp b/embedding/components/commandhandler/nsControllerCommandTable.cpp
index cda718282365..72491f59d970 100644
--- a/embedding/components/commandhandler/nsControllerCommandTable.cpp
+++ b/embedding/components/commandhandler/nsControllerCommandTable.cpp
@@ -205,7 +205,7 @@ nsControllerCommandTable::GetSupportedCommands(uint32_t* aCount,
                                                char*** aCommands)
 {
   char** commands =
-    static_cast<char **>(NS_Alloc(sizeof(char *) * mCommandsTable.Count()));
+    static_cast<char **>(moz_xmalloc(sizeof(char *) * mCommandsTable.Count()));
   *aCount = mCommandsTable.Count();
   *aCommands = commands;
 
diff --git a/extensions/spellcheck/hunspell/src/mozHunspell.cpp b/extensions/spellcheck/hunspell/src/mozHunspell.cpp
index d3caea669e8d..1324be9c8322 100644
--- a/extensions/spellcheck/hunspell/src/mozHunspell.cpp
+++ b/extensions/spellcheck/hunspell/src/mozHunspell.cpp
@@ -322,7 +322,7 @@ NS_IMETHODIMP mozHunspell::GetDictionaryList(char16_t ***aDictionaries,
     return NS_ERROR_NULL_POINTER;
 
   AppendNewStruct ans = {
-    (char16_t**) NS_Alloc(sizeof(char16_t*) * mDictionaries.Count()),
+    (char16_t**) moz_xmalloc(sizeof(char16_t*) * mDictionaries.Count()),
     0,
     false
   };
@@ -333,9 +333,9 @@ NS_IMETHODIMP mozHunspell::GetDictionaryList(char16_t ***aDictionaries,
   if (ans.failed) {
     while (ans.count) {
       --ans.count;
-      NS_Free(ans.dics[ans.count]);
+      free(ans.dics[ans.count]);
     }
-    NS_Free(ans.dics);
+    free(ans.dics);
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
diff --git a/gfx/thebes/gfxDWriteFontList.cpp b/gfx/thebes/gfxDWriteFontList.cpp
index a1a694c867ba..754a057896b0 100644
--- a/gfx/thebes/gfxDWriteFontList.cpp
+++ b/gfx/thebes/gfxDWriteFontList.cpp
@@ -779,14 +779,14 @@ gfxDWriteFontList::MakePlatformFont(const nsAString& aFontName,
     nsAutoString uniqueName;
     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
     if (NS_FAILED(rv)) {
-        NS_Free((void*)aFontData);
+        free((void*)aFontData);
         return nullptr;
     }
 
     FallibleTArray<uint8_t> newFontData;
 
     rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
-    NS_Free((void*)aFontData);
+    free((void*)aFontData);
 
     if (NS_FAILED(rv)) {
         return nullptr;
diff --git a/gfx/thebes/gfxFT2FontList.cpp b/gfx/thebes/gfxFT2FontList.cpp
index f0dbe3ec1599..59ba6e45ac37 100644
--- a/gfx/thebes/gfxFT2FontList.cpp
+++ b/gfx/thebes/gfxFT2FontList.cpp
@@ -266,12 +266,12 @@ FT2FontEntry::CreateFontEntry(const nsAString& aFontName,
         FT_New_Memory_Face(gfxToolkitPlatform::GetPlatform()->GetFTLibrary(),
                            aFontData, aLength, 0, &face);
     if (error != FT_Err_Ok) {
-        NS_Free((void*)aFontData);
+        free((void*)aFontData);
         return nullptr;
     }
     if (FT_Err_Ok != FT_Select_Charmap(face, FT_ENCODING_UNICODE)) {
         FT_Done_Face(face);
-        NS_Free((void*)aFontData);
+        free((void*)aFontData);
         return nullptr;
     }
     // Create our FT2FontEntry, which inherits the name of the userfont entry
@@ -299,7 +299,7 @@ class FTUserFontData {
     {
         FT_Done_Face(mFace);
         if (mFontData) {
-            NS_Free((void*)mFontData);
+            free((void*)mFontData);
         }
     }
 
diff --git a/gfx/thebes/gfxGDIFontList.cpp b/gfx/thebes/gfxGDIFontList.cpp
index 6550ba7718a0..405dce32ffc2 100644
--- a/gfx/thebes/gfxGDIFontList.cpp
+++ b/gfx/thebes/gfxGDIFontList.cpp
@@ -762,13 +762,13 @@ gfxGDIFontList::MakePlatformFont(const nsAString& aFontName,
                                  const uint8_t* aFontData,
                                  uint32_t aLength)
 {
-    // MakePlatformFont is responsible for deleting the font data with NS_Free
+    // MakePlatformFont is responsible for deleting the font data with free
     // so we set up a stack object to ensure it is freed even if we take an
     // early exit
     struct FontDataDeleter {
         FontDataDeleter(const uint8_t* aFontData)
             : mFontData(aFontData) { }
-        ~FontDataDeleter() { NS_Free((void*)mFontData); }
+        ~FontDataDeleter() { free((void*)mFontData); }
         const uint8_t *mFontData;
     };
     FontDataDeleter autoDelete(aFontData);
diff --git a/gfx/thebes/gfxMacPlatformFontList.mm b/gfx/thebes/gfxMacPlatformFontList.mm
index 1014c0a648d6..ba073e1f9682 100644
--- a/gfx/thebes/gfxMacPlatformFontList.mm
+++ b/gfx/thebes/gfxMacPlatformFontList.mm
@@ -971,7 +971,7 @@ new MacOSFontEntry(aFontName, fontRef,
 
 static void ReleaseData(void *info, const void *data, size_t size)
 {
-    NS_Free((void*)data);
+    free((void*)data);
 }
 
 gfxFontEntry*
diff --git a/gfx/thebes/gfxPangoFonts.cpp b/gfx/thebes/gfxPangoFonts.cpp
index 6566c49ec560..f98be1df03ca 100644
--- a/gfx/thebes/gfxPangoFonts.cpp
+++ b/gfx/thebes/gfxPangoFonts.cpp
@@ -473,7 +473,7 @@ class gfxDownloadedFcFontEntry : public gfxUserFcFontEntry {
 
     // mFontData holds the data used to instantiate the FT_Face;
     // this has to persist until we are finished with the face,
-    // then be released with NS_Free().
+    // then be released with free().
     const uint8_t* mFontData;
 
     FT_Face mFace;
@@ -522,7 +522,7 @@ gfxDownloadedFcFontEntry::~gfxDownloadedFcFontEntry()
         FcPatternDel(mPatterns[0], FC_FT_FACE);
     }
     FT_Done_Face(mFace);
-    NS_Free((void*)mFontData);
+    free((void*)mFontData);
 }
 
 typedef FcPattern* (*QueryFaceFunction)(const FT_Face face,
@@ -1706,7 +1706,7 @@ gfxPangoFontGroup::NewFontEntry(const nsAString& aFontName,
     FT_Error error =
         FT_New_Memory_Face(GetFTLibrary(), aFontData, aLength, 0, &face);
     if (error != 0) {
-        NS_Free((void*)aFontData);
+        free((void*)aFontData);
         return nullptr;
     }
 
diff --git a/gfx/thebes/gfxPlatform.cpp b/gfx/thebes/gfxPlatform.cpp
index 2e7eea6ab6e7..aea05ef40b05 100644
--- a/gfx/thebes/gfxPlatform.cpp
+++ b/gfx/thebes/gfxPlatform.cpp
@@ -1333,7 +1333,7 @@ gfxPlatform::MakePlatformFont(const nsAString& aFontName,
     // using the data to instantiate the font, and taking responsibility
     // for freeing it when no longer required.
     if (aFontData) {
-        NS_Free((void*)aFontData);
+        free((void*)aFontData);
     }
     return nullptr;
 }
diff --git a/gfx/thebes/gfxPlatformFontList.h b/gfx/thebes/gfxPlatformFontList.h
index 847c533966ab..e4bd94e13263 100644
--- a/gfx/thebes/gfxPlatformFontList.h
+++ b/gfx/thebes/gfxPlatformFontList.h
@@ -155,7 +155,7 @@ class gfxPlatformFontList : public gfxFontInfoLoader
                                           bool aItalic) = 0;
 
     // create a new platform font from downloaded data (@font-face)
-    // this method is responsible to ensure aFontData is NS_Free()'d
+    // this method is responsible to ensure aFontData is free()'d
     virtual gfxFontEntry* MakePlatformFont(const nsAString& aFontName,
                                            uint16_t aWeight,
                                            int16_t aStretch,
diff --git a/gfx/thebes/gfxPlatformMac.cpp b/gfx/thebes/gfxPlatformMac.cpp
index 81896b067954..512c8446606b 100644
--- a/gfx/thebes/gfxPlatformMac.cpp
+++ b/gfx/thebes/gfxPlatformMac.cpp
@@ -166,7 +166,7 @@ gfxPlatformMac::MakePlatformFont(const nsAString& aFontName,
 {
     // Ownership of aFontData is received here, and passed on to
     // gfxPlatformFontList::MakePlatformFont(), which must ensure the data
-    // is released with NS_Free when no longer needed
+    // is released with free when no longer needed
     return gfxPlatformFontList::PlatformFontList()->MakePlatformFont(aFontName,
                                                                      aWeight,
                                                                      aStretch,
diff --git a/gfx/thebes/gfxUserFontSet.cpp b/gfx/thebes/gfxUserFontSet.cpp
index eba65c5eabae..1e76003c36f8 100644
--- a/gfx/thebes/gfxUserFontSet.cpp
+++ b/gfx/thebes/gfxUserFontSet.cpp
@@ -47,15 +47,15 @@ class ExpandingMemoryStream : public ots::OTSStream {
 public:
     ExpandingMemoryStream(size_t initial, size_t limit)
         : mLength(initial), mLimit(limit), mOff(0) {
-        mPtr = NS_Alloc(mLength);
+        mPtr = moz_xmalloc(mLength);
     }
 
     ~ExpandingMemoryStream() {
-        NS_Free(mPtr);
+        free(mPtr);
     }
 
     // return the buffer, and give up ownership of it
-    // so the caller becomes responsible to call NS_Free
+    // so the caller becomes responsible to call free
     // when finished with it
     void* forget() {
         void* p = mPtr;
@@ -76,7 +76,7 @@ class ExpandingMemoryStream : public ots::OTSStream {
             if (newLength > mLimit) {
                 newLength = mLimit;
             }
-            mPtr = NS_Realloc(mPtr, newLength);
+            mPtr = moz_xrealloc(mPtr, newLength);
             mLength = newLength;
             return WriteRaw(data, length);
         }
diff --git a/gfx/thebes/gfxUserFontSet.h b/gfx/thebes/gfxUserFontSet.h
index 422b4c10c77f..e98fa0d102f1 100644
--- a/gfx/thebes/gfxUserFontSet.h
+++ b/gfx/thebes/gfxUserFontSet.h
@@ -611,14 +611,14 @@ class gfxUserFontEntry : public gfxFontEntry {
     // returns true if platform font creation sucessful (or local()
     // reference was next in line)
     // Ownership of aFontData is passed in here; the font set must
-    // ensure that it is eventually deleted with NS_Free().
+    // ensure that it is eventually deleted with free().
     bool FontDataDownloadComplete(const uint8_t* aFontData, uint32_t aLength,
                                   nsresult aDownloadStatus);
 
     // helper method for creating a platform font
     // returns true if platform font creation successful
     // Ownership of aFontData is passed in here; the font must
-    // ensure that it is eventually deleted with NS_Free().
+    // ensure that it is eventually deleted with free().
     bool LoadPlatformFont(const uint8_t* aFontData, uint32_t& aLength);
 
     // store metadata and src details for current src into aFontEntry
diff --git a/image/decoders/icon/android/nsIconChannel.cpp b/image/decoders/icon/android/nsIconChannel.cpp
index c690c836e63a..cd2e979fb764 100644
--- a/image/decoders/icon/android/nsIconChannel.cpp
+++ b/image/decoders/icon/android/nsIconChannel.cpp
@@ -72,7 +72,7 @@ moz_icon_to_channel(nsIURI* aURI, const nsACString& aFileExt,
   // then the ARGB pixel values with pre-multiplied Alpha
   const int channels = 4;
   long int buf_size = 2 + channels * height * width;
-  uint8_t* const buf = (uint8_t*)NS_Alloc(buf_size);
+  uint8_t* const buf = (uint8_t*)moz_xmalloc(buf_size);
   NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
   uint8_t* out = buf;
 
diff --git a/image/decoders/icon/gtk/nsIconChannel.cpp b/image/decoders/icon/gtk/nsIconChannel.cpp
index 2e0bae62b266..2608583621b9 100644
--- a/image/decoders/icon/gtk/nsIconChannel.cpp
+++ b/image/decoders/icon/gtk/nsIconChannel.cpp
@@ -47,7 +47,7 @@ moz_gdk_pixbuf_to_channel(GdkPixbuf* aPixbuf, nsIURI* aURI,
 
   const int n_channels = 4;
   gsize buf_size = 2 + n_channels * height * width;
-  uint8_t* const buf = (uint8_t*)NS_Alloc(buf_size);
+  uint8_t* const buf = (uint8_t*)moz_xmalloc(buf_size);
   NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
   uint8_t* out = buf;
 
@@ -89,7 +89,7 @@ moz_gdk_pixbuf_to_channel(GdkPixbuf* aPixbuf, nsIURI* aURI,
 
   // Prevent the leaking of buf
   if (NS_WARN_IF(NS_FAILED(rv))) {
-    NS_Free(buf);
+    free(buf);
     return rv;
   }
 
diff --git a/image/decoders/icon/qt/nsIconChannel.cpp b/image/decoders/icon/qt/nsIconChannel.cpp
index b864e152ae8b..11e452abb429 100644
--- a/image/decoders/icon/qt/nsIconChannel.cpp
+++ b/image/decoders/icon/qt/nsIconChannel.cpp
@@ -40,7 +40,7 @@ moz_qicon_to_channel(QImage* image, nsIURI* aURI,
 
   const int n_channels = 4;
   long int buf_size = 2 + n_channels * height * width;
-  uint8_t* const buf = (uint8_t*)NS_Alloc(buf_size);
+  uint8_t* const buf = (uint8_t*)moz_xmalloc(buf_size);
   NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
   uint8_t* out = buf;
 
diff --git a/intl/uconv/nsTextToSubURI.cpp b/intl/uconv/nsTextToSubURI.cpp
index 2c4e1be5a475..b438f4d50d9a 100644
--- a/intl/uconv/nsTextToSubURI.cpp
+++ b/intl/uconv/nsTextToSubURI.cpp
@@ -72,7 +72,7 @@ NS_IMETHODIMP  nsTextToSubURI::ConvertAndEscape(
     int32_t outlen = 0;
     if (NS_SUCCEEDED(rv = encoder->GetMaxLength(text, ulen, &outlen))) {
       if (outlen >= 256) {
-        pBuf = (char*)NS_Alloc(outlen+1);
+        pBuf = (char*)moz_xmalloc(outlen+1);
       }
       if (nullptr == pBuf) {
         outlen = 255;
@@ -95,7 +95,7 @@ NS_IMETHODIMP  nsTextToSubURI::ConvertAndEscape(
       }
     }
     if (pBuf != buf) {
-      NS_Free(pBuf);
+      free(pBuf);
     }
   }
   
@@ -138,7 +138,7 @@ NS_IMETHODIMP  nsTextToSubURI::UnEscapeAndConvert(
   int32_t len = strlen(unescaped);
   int32_t outlen = 0;
   if (NS_SUCCEEDED(rv = decoder->GetMaxLength(unescaped, len, &outlen))) {
-    pBuf = (char16_t *) NS_Alloc((outlen+1)*sizeof(char16_t));
+    pBuf = (char16_t *) moz_xmalloc((outlen+1)*sizeof(char16_t));
     if (nullptr == pBuf) {
       rv = NS_ERROR_OUT_OF_MEMORY;
     } else {
@@ -146,11 +146,11 @@ NS_IMETHODIMP  nsTextToSubURI::UnEscapeAndConvert(
         pBuf[outlen] = 0;
         *_retval = pBuf;
       } else {
-        NS_Free(pBuf);
+        free(pBuf);
       }
     }
   }
-  NS_Free(unescaped);
+  free(unescaped);
 
   return rv;
 }
@@ -203,7 +203,7 @@ nsresult nsTextToSubURI::convertURItoUnicode(const nsAFlatCString &aCharset,
   nsresult rv = unicodeDecoder->GetMaxLength(aURI.get(), srcLen, &dstLen);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  char16_t *ustr = (char16_t *) NS_Alloc(dstLen * sizeof(char16_t));
+  char16_t *ustr = (char16_t *) moz_xmalloc(dstLen * sizeof(char16_t));
   NS_ENSURE_TRUE(ustr, NS_ERROR_OUT_OF_MEMORY);
 
   rv = unicodeDecoder->Convert(aURI.get(), &srcLen, ustr, &dstLen);
@@ -211,7 +211,7 @@ nsresult nsTextToSubURI::convertURItoUnicode(const nsAFlatCString &aCharset,
   if (NS_SUCCEEDED(rv))
     _retval.Assign(ustr, dstLen);
   
-  NS_Free(ustr);
+  free(ustr);
 
   return rv;
 }
diff --git a/js/xpconnect/loader/mozJSComponentLoader.h b/js/xpconnect/loader/mozJSComponentLoader.h
index 293942c17bbb..e27a0e39a94f 100644
--- a/js/xpconnect/loader/mozJSComponentLoader.h
+++ b/js/xpconnect/loader/mozJSComponentLoader.h
@@ -118,7 +118,7 @@ class mozJSComponentLoader : public mozilla::ModuleLoader,
             }
 
             if (location)
-                NS_Free(location);
+                free(location);
 
             obj = nullptr;
             thisObjectKey = nullptr;
diff --git a/js/xpconnect/src/XPCJSID.cpp b/js/xpconnect/src/XPCJSID.cpp
index 63cdc136117d..548c2c66dbe0 100644
--- a/js/xpconnect/src/XPCJSID.cpp
+++ b/js/xpconnect/src/XPCJSID.cpp
@@ -33,9 +33,9 @@ nsJSID::nsJSID()
 nsJSID::~nsJSID()
 {
     if (mNumber && mNumber != gNoString)
-        NS_Free(mNumber);
+        free(mNumber);
     if (mName && mName != gNoString)
-        NS_Free(mName);
+        free(mName);
 }
 
 void nsJSID::Reset()
@@ -43,9 +43,9 @@ void nsJSID::Reset()
     mID = GetInvalidIID();
 
     if (mNumber && mNumber != gNoString)
-        NS_Free(mNumber);
+        free(mNumber);
     if (mName && mName != gNoString)
-        NS_Free(mName);
+        free(mName);
 
     mNumber = mName = nullptr;
 }
diff --git a/js/xpconnect/src/XPCWrappedJS.cpp b/js/xpconnect/src/XPCWrappedJS.cpp
index 27779fa5d30a..8e280f3600a1 100644
--- a/js/xpconnect/src/XPCWrappedJS.cpp
+++ b/js/xpconnect/src/XPCWrappedJS.cpp
@@ -624,7 +624,7 @@ nsXPCWrappedJS::DebugDump(int16_t depth)
         char * iid = GetClass()->GetIID().ToString();
         XPC_LOG_ALWAYS(("IID number is %s", iid ? iid : "invalid"));
         if (iid)
-            NS_Free(iid);
+            free(iid);
         XPC_LOG_ALWAYS(("nsXPCWrappedJSClass @ %x", mClass.get()));
 
         if (!IsRootWrapper())
diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
index 62636ca89f9d..088d9f37666c 100644
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -1481,7 +1481,7 @@ nsXPCWrappedJSClass::DebugDump(int16_t depth)
         char * iid = mIID.ToString();
         XPC_LOG_ALWAYS(("IID number is %s", iid ? iid : "invalid"));
         if (iid)
-            NS_Free(iid);
+            free(iid);
         XPC_LOG_ALWAYS(("InterfaceInfo @ %x", mInfo.get()));
         uint16_t methodCount = 0;
         if (depth) {
diff --git a/js/xpconnect/tests/components/native/xpctest_params.cpp b/js/xpconnect/tests/components/native/xpctest_params.cpp
index f7f462db63ec..5c651b3dd9fd 100644
--- a/js/xpconnect/tests/components/native/xpctest_params.cpp
+++ b/js/xpconnect/tests/components/native/xpctest_params.cpp
@@ -49,15 +49,15 @@ nsXPCTestParams::~nsXPCTestParams()
                                                                               \
     /* Copy b into rv. */                                                     \
     *rvLength = *bLength;                                                     \
-    *rv = static_cast<type*>(NS_Alloc(elemSize * (*bLength + padding)));      \
+    *rv = static_cast<type*>(moz_xmalloc(elemSize * (*bLength + padding)));   \
     if (!*rv)                                                                 \
         return NS_ERROR_OUT_OF_MEMORY;                                        \
     memcpy(*rv, *b, elemSize * (*bLength + padding));                         \
                                                                               \
     /* Copy a into b. */                                                      \
     *bLength = aLength;                                                       \
-    NS_Free(*b);                                                              \
-    *b = static_cast<type*>(NS_Alloc(elemSize * (aLength + padding)));        \
+    free(*b);                                                                 \
+    *b = static_cast<type*>(moz_xmalloc(elemSize * (aLength + padding)));     \
     if (!*b)                                                                  \
         return NS_ERROR_OUT_OF_MEMORY;                                        \
     memcpy(*b, a, elemSize * (aLength + padding));                            \
@@ -146,7 +146,7 @@ NS_IMETHODIMP nsXPCTestParams::TestString(const char * a, char * *b, char * *_re
 
     // XPCOM ownership rules dictate that overwritten inout params must be callee-freed.
     // See https://developer.mozilla.org/en/XPIDL
-    NS_Free(const_cast<char*>(bprime.get()));
+    free(const_cast<char*>(bprime.get()));
 
     return NS_OK;
 }
@@ -167,7 +167,7 @@ NS_IMETHODIMP nsXPCTestParams::TestWstring(const char16_t * a, char16_t * *b, ch
 
     // XPCOM ownership rules dictate that overwritten inout params must be callee-freed.
     // See https://developer.mozilla.org/en/XPIDL
-    NS_Free((void*)bprime.get());
+    free((void*)bprime.get());
 
     return NS_OK;
 }
@@ -297,7 +297,7 @@ NS_IMETHODIMP nsXPCTestParams::TestInterfaceIs(const nsIID* aIID, void* a,
 
     // rvIID is out-only, so nobody allocated an IID buffer for us. Do that now,
     // and store b's IID in the new buffer.
-    *rvIID = static_cast<nsIID*>(NS_Alloc(sizeof(nsID)));
+    *rvIID = static_cast<nsIID*>(moz_xmalloc(sizeof(nsID)));
     if (!*rvIID)
         return NS_ERROR_OUT_OF_MEMORY;
     **rvIID = **bIID;
@@ -328,7 +328,7 @@ NS_IMETHODIMP nsXPCTestParams::TestInterfaceIsArray(uint32_t aLength, const nsII
 {
     // Transfer the IIDs. See the comments in TestInterfaceIs (above) for an
     // explanation of what we're doing.
-    *rvIID = static_cast<nsIID*>(NS_Alloc(sizeof(nsID)));
+    *rvIID = static_cast<nsIID*>(moz_xmalloc(sizeof(nsID)));
     if (!*rvIID)
         return NS_ERROR_OUT_OF_MEMORY;
     **rvIID = **bIID;
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
index 62b925e4f252..ee9b119c0714 100644
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -10413,7 +10413,7 @@ int ReflowCountMgr::RemoveItems(PLHashEntry *he, int i, void *arg)
   char *str = (char *)he->key;
   ReflowCounter * counter = (ReflowCounter *)he->value;
   delete counter;
-  NS_Free(str);
+  free(str);
 
   return HT_ENUMERATE_REMOVE;
 }
@@ -10424,7 +10424,7 @@ int ReflowCountMgr::RemoveIndiItems(PLHashEntry *he, int i, void *arg)
   char *str = (char *)he->key;
   IndiReflowCounter * counter = (IndiReflowCounter *)he->value;
   delete counter;
-  NS_Free(str);
+  free(str);
 
   return HT_ENUMERATE_REMOVE;
 }
diff --git a/layout/inspector/inDOMUtils.cpp b/layout/inspector/inDOMUtils.cpp
index b129293793f5..042fb17169ae 100644
--- a/layout/inspector/inDOMUtils.cpp
+++ b/layout/inspector/inDOMUtils.cpp
@@ -96,7 +96,7 @@ inDOMUtils::GetAllStyleSheets(nsIDOMDocument *aDocument, uint32_t *aLength,
     sheets.AppendElement(document->GetStyleSheetAt(i));
   }
 
-  nsISupports** ret = static_cast<nsISupports**>(NS_Alloc(sheets.Count() *
+  nsISupports** ret = static_cast<nsISupports**>(moz_xmalloc(sheets.Count() *
                                                  sizeof(nsISupports*)));
 
   for (int32_t i = 0; i < sheets.Count(); i++) {
@@ -773,7 +773,7 @@ inDOMUtils::GetCSSValuesForProperty(const nsAString& aProperty,
 
   *aLength = array.Length();
   char16_t** ret =
-    static_cast<char16_t**>(NS_Alloc(*aLength * sizeof(char16_t*)));
+    static_cast<char16_t**>(moz_xmalloc(*aLength * sizeof(char16_t*)));
   for (uint32_t i = 0; i < *aLength; ++i) {
     ret[i] = ToNewUnicode(array[i]);
   }
diff --git a/layout/printing/nsPrintData.cpp b/layout/printing/nsPrintData.cpp
index e08e13cbd0ac..85bc4402e2ae 100644
--- a/layout/printing/nsPrintData.cpp
+++ b/layout/printing/nsPrintData.cpp
@@ -98,7 +98,7 @@ nsPrintData::~nsPrintData()
   delete mPrintObject;
 
   if (mBrandName) {
-    NS_Free(mBrandName);
+    free(mBrandName);
   }
 }
 
diff --git a/layout/style/FontFace.cpp b/layout/style/FontFace.cpp
index e90932fb564a..53a01aad1a71 100644
--- a/layout/style/FontFace.cpp
+++ b/layout/style/FontFace.cpp
@@ -130,7 +130,7 @@ FontFace::~FontFace()
   }
 
   if (mSourceBuffer) {
-    NS_Free(mSourceBuffer);
+    free(mSourceBuffer);
   }
 }
 
diff --git a/layout/style/FontFaceSet.cpp b/layout/style/FontFaceSet.cpp
index 2d480777e908..af1c61b3a68e 100644
--- a/layout/style/FontFaceSet.cpp
+++ b/layout/style/FontFaceSet.cpp
@@ -1262,7 +1262,7 @@ FontFaceSet::SyncLoadFontData(gfxUserFontEntry* aFontToLoad,
   aBufferLength = static_cast<uint32_t>(bufferLength64);
 
   // read all the decoded data
-  aBuffer = static_cast<uint8_t*> (NS_Alloc(sizeof(uint8_t) * aBufferLength));
+  aBuffer = static_cast<uint8_t*> (moz_xmalloc(sizeof(uint8_t) * aBufferLength));
   if (!aBuffer) {
     aBufferLength = 0;
     return NS_ERROR_OUT_OF_MEMORY;
@@ -1289,7 +1289,7 @@ FontFaceSet::SyncLoadFontData(gfxUserFontEntry* aFontToLoad,
   }
 
   if (NS_FAILED(rv)) {
-    NS_Free(aBuffer);
+    free(aBuffer);
     aBuffer = nullptr;
     aBufferLength = 0;
     return rv;
diff --git a/layout/style/StyleRule.cpp b/layout/style/StyleRule.cpp
index 729a6f0271f5..09f77a7799ca 100644
--- a/layout/style/StyleRule.cpp
+++ b/layout/style/StyleRule.cpp
@@ -210,7 +210,7 @@ nsPseudoClassList::~nsPseudoClassList(void)
   if (nsCSSPseudoClasses::HasSelectorListArg(mType)) {
     delete u.mSelectors;
   } else if (u.mMemory) {
-    NS_Free(u.mMemory);
+    free(u.mMemory);
   }
   NS_CSS_DELETE_LIST_MEMBER(nsPseudoClassList, this, mNext);
 }
diff --git a/layout/style/StyleRule.h b/layout/style/StyleRule.h
index 6bce38497e56..8ccc8f4efadc 100644
--- a/layout/style/StyleRule.h
+++ b/layout/style/StyleRule.h
@@ -71,7 +71,7 @@ struct nsPseudoClassList {
     //      (if nsCSSPseudoClasses::HasNthPairArg(mType))
     //   d. a selector list, which means mSelectors is non-null
     //      (if nsCSSPseudoClasses::HasSelectorListArg(mType))
-    void*           mMemory; // mString and mNumbers use NS_Alloc/NS_Free
+    void*           mMemory; // mString and mNumbers use moz_xmalloc/free
     char16_t*      mString;
     int32_t*        mNumbers;
     nsCSSSelectorList* mSelectors;
diff --git a/layout/style/nsStyleStruct.cpp b/layout/style/nsStyleStruct.cpp
index d1d358659cc5..8d31c0125816 100644
--- a/layout/style/nsStyleStruct.cpp
+++ b/layout/style/nsStyleStruct.cpp
@@ -1886,7 +1886,7 @@ nsStyleImage::SetNull()
   else if (mType == eStyleImageType_Image)
     NS_RELEASE(mImage);
   else if (mType == eStyleImageType_Element)
-    NS_Free(mElementId);
+    free(mElementId);
 
   mType = eStyleImageType_Null;
   mCropRect = nullptr;
@@ -2984,7 +2984,7 @@ nsStyleContentData::~nsStyleContentData()
              mType == eStyleContentType_Counters) {
     mContent.mCounters->Release();
   } else if (mContent.mString) {
-    NS_Free(mContent.mString);
+    free(mContent.mString);
   }
 }
 
diff --git a/memory/replace/dmd/dmd.py b/memory/replace/dmd/dmd.py
index a6d0110c2ab6..d2ea3d042c4a 100755
--- a/memory/replace/dmd/dmd.py
+++ b/memory/replace/dmd/dmd.py
@@ -37,8 +37,6 @@
     'memalign',
     'operator new(',
     'operator new[](',
-    'NS_Alloc',
-    'NS_Realloc',
     'g_slice_alloc',
     # This one necessary to fully filter some sequences of allocation functions
     # that happen in practice. Note that ??? entries that follow non-allocation
diff --git a/modules/libpref/Preferences.cpp b/modules/libpref/Preferences.cpp
index aab0277284d4..c4686628df4e 100644
--- a/modules/libpref/Preferences.cpp
+++ b/modules/libpref/Preferences.cpp
@@ -978,7 +978,7 @@ Preferences::WritePrefFile(nsIFile* aFile)
     if (*walker) {
       outStream->Write(*walker, strlen(*walker), &writeAmount);
       outStream->Write(NS_LINEBREAK, NS_LINEBREAK_LEN, &writeAmount);
-      NS_Free(*walker);
+      free(*walker);
     }
   }
 
diff --git a/netwerk/base/nsStandardURL.cpp b/netwerk/base/nsStandardURL.cpp
index c8b3e0e69483..b4a7bf3f3d32 100644
--- a/netwerk/base/nsStandardURL.cpp
+++ b/netwerk/base/nsStandardURL.cpp
@@ -889,7 +889,7 @@ nsStandardURL::AppendToSubstring(uint32_t pos,
     if (UINT32_MAX - ((uint32_t)len + 1) < tailLen)
         return nullptr;
 
-    char *result = (char *) NS_Alloc(len + tailLen + 1);
+    char *result = (char *) moz_xmalloc(len + tailLen + 1);
     if (result) {
         memcpy(result, mSpec.get() + pos, len);
         memcpy(result + len, tail, tailLen);
diff --git a/netwerk/cache/nsDiskCacheDeviceSQL.cpp b/netwerk/cache/nsDiskCacheDeviceSQL.cpp
index dfdf86e4f059..a2b9e16adf19 100644
--- a/netwerk/cache/nsDiskCacheDeviceSQL.cpp
+++ b/netwerk/cache/nsDiskCacheDeviceSQL.cpp
@@ -2286,7 +2286,7 @@ nsOfflineCacheDevice::RunSimpleQuery(mozIStorageStatement * statement,
   }
 
   *count = valArray.Length();
-  char **ret = static_cast<char **>(NS_Alloc(*count * sizeof(char*)));
+  char **ret = static_cast<char **>(moz_xmalloc(*count * sizeof(char*)));
   if (!ret) return NS_ERROR_OUT_OF_MEMORY;
 
   for (uint32_t i = 0; i <  *count; i++) {
diff --git a/netwerk/protocol/websocket/WebSocketChannel.cpp b/netwerk/protocol/websocket/WebSocketChannel.cpp
index e8e52765e585..fea823d15080 100644
--- a/netwerk/protocol/websocket/WebSocketChannel.cpp
+++ b/netwerk/protocol/websocket/WebSocketChannel.cpp
@@ -2054,7 +2054,7 @@ WebSocketChannel::PrimeNewOutgoingMessage()
       return;
     }
     mask = * reinterpret_cast<uint32_t *>(buffer);
-    NS_Free(buffer);
+    free(buffer);
   } while (!mask);
   NetworkEndian::writeUint32(payload - sizeof(uint32_t), mask);
 
@@ -2492,7 +2492,7 @@ WebSocketChannel::SetupRequest()
   rv = mRandomGenerator->GenerateRandomBytes(16, &secKey);
   NS_ENSURE_SUCCESS(rv, rv);
   char* b64 = PL_Base64Encode((const char *)secKey, 16, nullptr);
-  NS_Free(secKey);
+  free(secKey);
   if (!b64)
     return NS_ERROR_OUT_OF_MEMORY;
   secKeyString.Assign(b64);
diff --git a/netwerk/streamconv/converters/nsDirIndexParser.cpp b/netwerk/streamconv/converters/nsDirIndexParser.cpp
index abfce2f1d0b0..a25f28039fd6 100644
--- a/netwerk/streamconv/converters/nsDirIndexParser.cpp
+++ b/netwerk/streamconv/converters/nsDirIndexParser.cpp
@@ -255,7 +255,7 @@ nsDirIndexParser::ParseData(nsIDirIndex *aIdx, char* aDataStr) {
               aIdx->SetDescription(result);
             success = true;
           }
-          NS_Free(result);
+          free(result);
         } else {
           NS_WARNING("UnEscapeAndConvert error");
         }
diff --git a/parser/html/nsParserUtils.cpp b/parser/html/nsParserUtils.cpp
index ccd41666186e..27ffc0d128db 100644
--- a/parser/html/nsParserUtils.cpp
+++ b/parser/html/nsParserUtils.cpp
@@ -173,7 +173,7 @@ nsParserUtils::ParseFragment(const nsAString& aFragment,
       char* escapedSpec = nsEscapeHTML(spec.get());
       if (escapedSpec)
         base += escapedSpec;
-      NS_Free(escapedSpec);
+      free(escapedSpec);
       base.Append('"');
       tagStack.AppendElement(NS_ConvertUTF8toUTF16(base));
     }  else {
diff --git a/rdf/base/nsInMemoryDataSource.cpp b/rdf/base/nsInMemoryDataSource.cpp
index d09163583fe2..87dd8d7df232 100644
--- a/rdf/base/nsInMemoryDataSource.cpp
+++ b/rdf/base/nsInMemoryDataSource.cpp
@@ -908,7 +908,7 @@ InMemoryDataSource::LogOperation(const char* aOperation,
         PR_LogPrint
            ("  -->(\"%s\")\n", valueCStr);
 
-        NS_Free(valueCStr);
+        free(valueCStr);
     }
     else {
         PR_LogPrint
diff --git a/rdf/base/nsRDFContentSink.cpp b/rdf/base/nsRDFContentSink.cpp
index 6e9ab71a3d74..a0d592750047 100644
--- a/rdf/base/nsRDFContentSink.cpp
+++ b/rdf/base/nsRDFContentSink.cpp
@@ -455,7 +455,7 @@ RDFContentSinkImpl::HandleEndElement(const char16_t *aName)
                  ("rdfxml: extra close tag '%s' at line %d",
                   tagCStr, 0/*XXX fix me */);
 
-          NS_Free(tagCStr);
+          free(tagCStr);
       }
 #endif
 
diff --git a/rdf/datasource/nsFileSystemDataSource.cpp b/rdf/datasource/nsFileSystemDataSource.cpp
index 4ccca1d6009d..4b06a303dbd5 100644
--- a/rdf/datasource/nsFileSystemDataSource.cpp
+++ b/rdf/datasource/nsFileSystemDataSource.cpp
@@ -1012,7 +1012,7 @@ FileSystemDataSource::GetFolderList(nsIRDFResource *source, bool allowHidden,
             continue;
   
         nsAutoCString           leaf(escLeafStr);
-        NS_Free(escLeafStr);
+        free(escLeafStr);
         escLeafStr = nullptr;
 
         // using nsEscape() [above] doesn't escape slashes, so do that by hand
diff --git a/security/manager/ssl/src/nsNSSCallbacks.cpp b/security/manager/ssl/src/nsNSSCallbacks.cpp
index f97cdeb65926..fb86fe7823b7 100644
--- a/security/manager/ssl/src/nsNSSCallbacks.cpp
+++ b/security/manager/ssl/src/nsNSSCallbacks.cpp
@@ -856,7 +856,7 @@ void PK11PasswordPromptRunnable::RunOnTargetThread()
   
   if (NS_SUCCEEDED(rv) && value) {
     mResult = ToNewUTF8String(nsDependentString(password));
-    NS_Free(password);
+    free(password);
   }
 }
 
diff --git a/security/manager/ssl/src/nsRandomGenerator.cpp b/security/manager/ssl/src/nsRandomGenerator.cpp
index a97de7e7cd94..9d4f7593c081 100644
--- a/security/manager/ssl/src/nsRandomGenerator.cpp
+++ b/security/manager/ssl/src/nsRandomGenerator.cpp
@@ -30,7 +30,7 @@ nsRandomGenerator::GenerateRandomBytes(uint32_t aLength,
     return NS_ERROR_FAILURE;
   }
 
-  uint8_t* buf = reinterpret_cast<uint8_t*>(NS_Alloc(aLength));
+  uint8_t* buf = reinterpret_cast<uint8_t*>(moz_xmalloc(aLength));
   if (!buf) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -38,7 +38,7 @@ nsRandomGenerator::GenerateRandomBytes(uint32_t aLength,
   SECStatus srv = PK11_GenerateRandomOnSlot(slot, buf, aLength);
 
   if (srv != SECSuccess) {
-    NS_Free(buf);
+    free(buf);
     return NS_ERROR_FAILURE;
   }
 
diff --git a/storage/public/mozIStorageBindingParams.idl b/storage/public/mozIStorageBindingParams.idl
index 81d9e6efb3f8..2c537aaf02c5 100644
--- a/storage/public/mozIStorageBindingParams.idl
+++ b/storage/public/mozIStorageBindingParams.idl
@@ -40,7 +40,7 @@ interface mozIStorageBindingParams : nsISupports {
    void bindUTF8StringAsBlobByName(in AUTF8String aName, in AUTF8String aValue);
 
    // The function adopts the storage for the provided blob.  After calling
-   // this function, mozStorage will ensure that NS_Free is called on the
+   // this function, mozStorage will ensure that free is called on the
    // underlying pointer.
    [noscript]
    void bindAdoptedBlobByName(in AUTF8String aName,
@@ -77,7 +77,7 @@ interface mozIStorageBindingParams : nsISupports {
    void bindUTF8StringAsBlobByIndex(in unsigned long aIndex, in AUTF8String aValue);
 
    // The function adopts the storage for the provided blob.  After calling
-   // this function, mozStorage will ensure that NS_Free is called on the
+   // this function, mozStorage will ensure that free is called on the
    // underlying pointer.
    [noscript]
    void bindAdoptedBlobByIndex(in unsigned long aIndex,
diff --git a/storage/src/Variant.h b/storage/src/Variant.h
index 3a252a5ca1fb..aa1a6558bfdb 100644
--- a/storage/src/Variant.h
+++ b/storage/src/Variant.h
@@ -281,7 +281,7 @@ struct variant_storage_traits<uint8_t[], true>
   static inline void destroy(StorageType &aData)
   {
     if (aData.first) {
-      NS_Free(aData.first);
+      free(aData.first);
       aData.first = nullptr;
     }
   }
diff --git a/storage/src/mozStorageBindingParams.cpp b/storage/src/mozStorageBindingParams.cpp
index 359bdd8b5a31..169fd1b1fcf9 100644
--- a/storage/src/mozStorageBindingParams.cpp
+++ b/storage/src/mozStorageBindingParams.cpp
@@ -92,7 +92,7 @@ sqlite3_T_blob(BindingColumnData aData,
                int aSize)
 {
   return ::sqlite3_bind_blob(aData.stmt, aData.column + 1, aBlob, aSize,
-                             NS_Free);
+                             free);
 
 }
 
diff --git a/storage/src/mozStorageConnection.cpp b/storage/src/mozStorageConnection.cpp
index f803b8610b9f..d1fe97a04ccb 100644
--- a/storage/src/mozStorageConnection.cpp
+++ b/storage/src/mozStorageConnection.cpp
@@ -130,7 +130,7 @@ sqlite3_T_blob(sqlite3_context *aCtx,
                const void *aData,
                int aSize)
 {
-  ::sqlite3_result_blob(aCtx, aData, aSize, NS_Free);
+  ::sqlite3_result_blob(aCtx, aData, aSize, free);
   return SQLITE_OK;
 }
 
diff --git a/storage/src/variantToSQLiteT_impl.h b/storage/src/variantToSQLiteT_impl.h
index 30d58f012322..f1e68fb8fb64 100644
--- a/storage/src/variantToSQLiteT_impl.h
+++ b/storage/src/variantToSQLiteT_impl.h
@@ -107,7 +107,7 @@ variantToSQLiteT(T aObj,
       if (type != nsIDataType::VTYPE_UINT8) {
         // Technically this could leak with certain data types, but somebody was
         // being stupid passing us this anyway.
-        NS_Free(data);
+        free(data);
         return SQLITE_MISMATCH;
       }
 
diff --git a/toolkit/components/commandlines/nsCommandLine.cpp b/toolkit/components/commandlines/nsCommandLine.cpp
index 6ddf0d35f118..d6543c7725fd 100644
--- a/toolkit/components/commandlines/nsCommandLine.cpp
+++ b/toolkit/components/commandlines/nsCommandLine.cpp
@@ -489,7 +489,7 @@ LogConsoleMessage(const char16_t* fmt, ...)
   if (cs)
     cs->LogStringMessage(msg);
 
-  NS_Free(msg);
+  free(msg);
 }
 
 nsresult
diff --git a/toolkit/components/filepicker/nsFileView.cpp b/toolkit/components/filepicker/nsFileView.cpp
index f0e7a52fdaa1..8ba8d45682cd 100644
--- a/toolkit/components/filepicker/nsFileView.cpp
+++ b/toolkit/components/filepicker/nsFileView.cpp
@@ -293,7 +293,7 @@ nsFileView::~nsFileView()
 {
   uint32_t count = mCurrentFilters.Length();
   for (uint32_t i = 0; i < count; ++i)
-    NS_Free(mCurrentFilters[i]);
+    free(mCurrentFilters[i]);
 }
 
 nsresult
@@ -469,7 +469,7 @@ nsFileView::SetFilter(const nsAString& aFilterString)
 {
   uint32_t filterCount = mCurrentFilters.Length();
   for (uint32_t i = 0; i < filterCount; ++i)
-    NS_Free(mCurrentFilters[i]);
+    free(mCurrentFilters[i]);
   mCurrentFilters.Clear();
 
   nsAString::const_iterator start, iter, end;
@@ -498,7 +498,7 @@ nsFileView::SetFilter(const nsAString& aFilterString)
       return NS_ERROR_OUT_OF_MEMORY;
 
     if (!mCurrentFilters.AppendElement(filter)) {
-      NS_Free(filter);
+      free(filter);
       return NS_ERROR_OUT_OF_MEMORY;
     }
 
diff --git a/toolkit/components/parentalcontrols/nsParentalControlsServiceWin.cpp b/toolkit/components/parentalcontrols/nsParentalControlsServiceWin.cpp
index 9c2aeec2e4f8..5b102fd38952 100644
--- a/toolkit/components/parentalcontrols/nsParentalControlsServiceWin.cpp
+++ b/toolkit/components/parentalcontrols/nsParentalControlsServiceWin.cpp
@@ -283,7 +283,7 @@ nsParentalControlsService::RequestURIOverrides(nsIArray *aTargets, nsIInterfaceR
 
   // Free up the allocated strings in our array
   for (idx = 0; idx < uriIdx; idx++)
-    NS_Free((void*)arrUrls[idx]);
+    free((void*)arrUrls[idx]);
 
   return NS_OK;
 }
diff --git a/toolkit/components/places/nsAnnoProtocolHandler.cpp b/toolkit/components/places/nsAnnoProtocolHandler.cpp
index 769bb8ceba33..27d45f9ff508 100644
--- a/toolkit/components/places/nsAnnoProtocolHandler.cpp
+++ b/toolkit/components/places/nsAnnoProtocolHandler.cpp
@@ -130,7 +130,7 @@ class faviconAsyncLoader : public AsyncStatementCallback
                  "Failed to write all of our data out to the stream!");
 
     // Free our favicon array.
-    NS_Free(favicon);
+    free(favicon);
 
     // Handle an error to write if it occurred, but only after we've freed our
     // favicon.
diff --git a/toolkit/components/places/nsNavHistoryQuery.cpp b/toolkit/components/places/nsNavHistoryQuery.cpp
index 24bdc64848ec..3e9865b4c1fd 100644
--- a/toolkit/components/places/nsNavHistoryQuery.cpp
+++ b/toolkit/components/places/nsNavHistoryQuery.cpp
@@ -1148,7 +1148,7 @@ NS_IMETHODIMP nsNavHistoryQuery::GetTags(nsIVariant **aTags)
   else {
     // Note: The resulting nsIVariant dupes both the array and its elements.
     const char16_t **array = reinterpret_cast<const char16_t **>
-                              (NS_Alloc(arrayLen * sizeof(char16_t *)));
+                              (moz_xmalloc(arrayLen * sizeof(char16_t *)));
     NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);
 
     for (uint32_t i = 0; i < arrayLen; ++i) {
@@ -1159,7 +1159,7 @@ NS_IMETHODIMP nsNavHistoryQuery::GetTags(nsIVariant **aTags)
                          nullptr,
                          arrayLen,
                          reinterpret_cast<void *>(array));
-    NS_Free(array);
+    free(array);
   }
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -1202,7 +1202,7 @@ NS_IMETHODIMP nsNavHistoryQuery::SetTags(nsIVariant *aTags)
         char **charArray = reinterpret_cast<char **>(array);
         for (uint32_t i = 0; i < arrayLen; ++i) {
           if (charArray[i])
-            NS_Free(charArray[i]);
+            free(charArray[i]);
         }
       }
       break;
@@ -1217,7 +1217,7 @@ NS_IMETHODIMP nsNavHistoryQuery::SetTags(nsIVariant *aTags)
       break;
     // The other types are primitives that do not need to be freed.
     }
-    NS_Free(array);
+    free(array);
     return NS_ERROR_ILLEGAL_VALUE;
   }
 
@@ -1229,7 +1229,7 @@ NS_IMETHODIMP nsNavHistoryQuery::SetTags(nsIVariant *aTags)
 
     // Don't allow nulls.
     if (!tags[i]) {
-      NS_Free(tags);
+      free(tags);
       return NS_ERROR_ILLEGAL_VALUE;
     }
 
@@ -1239,14 +1239,14 @@ NS_IMETHODIMP nsNavHistoryQuery::SetTags(nsIVariant *aTags)
     // fancy; the SQL that's built from the tags relies on no dupes.
     if (!mTags.Contains(tag)) {
       if (!mTags.AppendElement(tag)) {
-        NS_Free(tags[i]);
-        NS_Free(tags);
+        free(tags[i]);
+        free(tags);
         return NS_ERROR_OUT_OF_MEMORY;
       }
     }
-    NS_Free(tags[i]);
+    free(tags[i]);
   }
-  NS_Free(tags);
+  free(tags);
 
   mTags.Sort();
 
@@ -1310,7 +1310,7 @@ NS_IMETHODIMP nsNavHistoryQuery::GetTransitions(uint32_t* aCount,
   uint32_t* transitions = nullptr;
   if (count > 0) {
     transitions = reinterpret_cast<uint32_t*>
-                  (NS_Alloc(count * sizeof(uint32_t)));
+                  (moz_xmalloc(count * sizeof(uint32_t)));
     NS_ENSURE_TRUE(transitions, NS_ERROR_OUT_OF_MEMORY);
     for (uint32_t i = 0; i < count; ++i) {
       transitions[i] = mTransitions[i];
diff --git a/toolkit/crashreporter/mac_utils.mm b/toolkit/crashreporter/mac_utils.mm
index 9615c25d4a00..bf70ad1d67c9 100644
--- a/toolkit/crashreporter/mac_utils.mm
+++ b/toolkit/crashreporter/mac_utils.mm
@@ -17,12 +17,12 @@ void GetObjCExceptionInfo(void* inException, nsACString& outString)
   unsigned int nameLength = [name length];
   unsigned int reasonLength = [reason length];
 
-  unichar* nameBuffer = (unichar*)NS_Alloc(sizeof(unichar) * (nameLength + 1));
+  unichar* nameBuffer = (unichar*)moz_xmalloc(sizeof(unichar) * (nameLength + 1));
   if (!nameBuffer)
     return;
-  unichar* reasonBuffer = (unichar*)NS_Alloc(sizeof(unichar) * (reasonLength + 1));
+  unichar* reasonBuffer = (unichar*)moz_xmalloc(sizeof(unichar) * (reasonLength + 1));
   if (!reasonBuffer) {
-    NS_Free(nameBuffer);
+    free(nameBuffer);
     return;
   }
 
@@ -36,6 +36,6 @@ void GetObjCExceptionInfo(void* inException, nsACString& outString)
   outString.AppendLiteral(": ");
   AppendUTF16toUTF8(reinterpret_cast<const char16_t*>(reasonBuffer), outString);
 
-  NS_Free(nameBuffer);
-  NS_Free(reasonBuffer);
+  free(nameBuffer);
+  free(reasonBuffer);
 }
diff --git a/toolkit/crashreporter/nsExceptionHandler.cpp b/toolkit/crashreporter/nsExceptionHandler.cpp
index 4b9aef96d401..dfdd1382811b 100644
--- a/toolkit/crashreporter/nsExceptionHandler.cpp
+++ b/toolkit/crashreporter/nsExceptionHandler.cpp
@@ -1645,22 +1645,22 @@ nsresult UnsetExceptionHandler()
   lastRunCrashID = nullptr;
 
   if (pendingDirectory) {
-    NS_Free(pendingDirectory);
+    free(pendingDirectory);
     pendingDirectory = nullptr;
   }
 
   if (crashReporterPath) {
-    NS_Free(crashReporterPath);
+    free(crashReporterPath);
     crashReporterPath = nullptr;
   }
 
   if (eventsDirectory) {
-    NS_Free(eventsDirectory);
+    free(eventsDirectory);
     eventsDirectory = nullptr;
   }
 
   if (memoryReportPath) {
-    NS_Free(memoryReportPath);
+    free(memoryReportPath);
     memoryReportPath = nullptr;
   }
 
@@ -2245,7 +2245,7 @@ SetCrashEventsDir(nsIFile* aDir)
   }
 
   if (eventsDirectory) {
-    NS_Free(eventsDirectory);
+    free(eventsDirectory);
   }
 
 #ifdef XP_WIN
@@ -2273,7 +2273,7 @@ SetCrashEventsDir(nsIFile* aDir)
   PR_SetEnv(eventsEnv);
 
   if (oldEventsEnv) {
-    NS_Free(oldEventsEnv);
+    free(oldEventsEnv);
   }
 #endif
 }
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index bd5f5f2dd0d9..8cbdc10603be 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -2044,7 +2044,7 @@ ShowProfileManager(nsIToolkitProfileService* aProfileSvc,
       NS_ENSURE_SUCCESS(rv, rv);
 
       CopyUTF16toUTF8(profileNamePtr, profileName);
-      NS_Free(profileNamePtr);
+      free(profileNamePtr);
 
       lock->Unlock();
     }
diff --git a/toolkit/xre/nsConsoleWriter.cpp b/toolkit/xre/nsConsoleWriter.cpp
index bfccd0727897..952e88003f2c 100644
--- a/toolkit/xre/nsConsoleWriter.cpp
+++ b/toolkit/xre/nsConsoleWriter.cpp
@@ -91,5 +91,5 @@ WriteConsoleLog()
   }
 
   PR_Close(file);
-  NS_Free(messages);
+  free(messages);
 }
diff --git a/uriloader/exthandler/android/nsExternalSharingAppService.cpp b/uriloader/exthandler/android/nsExternalSharingAppService.cpp
index c6a67f2cc665..9ddeab5298e0 100644
--- a/uriloader/exthandler/android/nsExternalSharingAppService.cpp
+++ b/uriloader/exthandler/android/nsExternalSharingAppService.cpp
@@ -50,8 +50,8 @@ nsExternalSharingAppService::GetSharingApps(const nsAString & aMIMEType,
                                                   nullptr, sendAction);
   array->GetLength(aLen);
   *aHandlers =
-    static_cast<nsISharingHandlerApp**>(NS_Alloc(sizeof(nsISharingHandlerApp*)
-                                                 * *aLen));
+    static_cast<nsISharingHandlerApp**>(moz_xmalloc(sizeof(nsISharingHandlerApp*)
+                                                    * *aLen));
   for (uint32_t i = 0; i < *aLen; i++) {
     rv = array->QueryElementAt(i, NS_GET_IID(nsISharingHandlerApp),
                                (void**)(*aHandlers + i));
diff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp
index 2acb7ed2eb36..7c601fc36470 100644
--- a/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -1405,7 +1405,7 @@ nsresult nsExternalAppHandler::SetUpTempFile(nsIChannel * aChannel)
   nsAutoCString tempLeafName;
   nsDependentCSubstring randomData(reinterpret_cast<const char*>(buffer), requiredBytesLength);
   rv = Base64Encode(randomData, tempLeafName);
-  NS_Free(buffer);
+  free(buffer);
   buffer = nullptr;
   NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/widget/cocoa/nsPrintDialogX.mm b/widget/cocoa/nsPrintDialogX.mm
index 35b3d2287953..a3724b1c9153 100644
--- a/widget/cocoa/nsPrintDialogX.mm
+++ b/widget/cocoa/nsPrintDialogX.mm
@@ -61,9 +61,9 @@
       CFRelease(cfTitleString);
     }
     for (int32_t i = titleCount - 1; i >= 0; i--) {
-      NS_Free(docTitles[i]);
+      free(docTitles[i]);
     }
-    NS_Free(docTitles);
+    free(docTitles);
     docTitles = NULL;
     titleCount = 0;
   }
diff --git a/widget/windows/nsFilePicker.cpp b/widget/windows/nsFilePicker.cpp
index 22e9033172bb..bf11aed87af9 100644
--- a/widget/windows/nsFilePicker.cpp
+++ b/widget/windows/nsFilePicker.cpp
@@ -179,7 +179,7 @@ nsFilePicker::nsFilePicker() :
 nsFilePicker::~nsFilePicker()
 {
   if (mLastUsedUnicodeDirectory) {
-    NS_Free(mLastUsedUnicodeDirectory);
+    free(mLastUsedUnicodeDirectory);
     mLastUsedUnicodeDirectory = nullptr;
   }
   CoUninitialize();
@@ -1276,7 +1276,7 @@ nsFilePicker::RememberLastUsedDirectory()
   }
 
   if (mLastUsedUnicodeDirectory) {
-    NS_Free(mLastUsedUnicodeDirectory);
+    free(mLastUsedUnicodeDirectory);
     mLastUsedUnicodeDirectory = nullptr;
   }
   mLastUsedUnicodeDirectory = ToNewUnicode(newDir);
diff --git a/xpcom/base/nsCycleCollector.cpp b/xpcom/base/nsCycleCollector.cpp
index 794a790e2f5d..35117c089a08 100644
--- a/xpcom/base/nsCycleCollector.cpp
+++ b/xpcom/base/nsCycleCollector.cpp
@@ -633,7 +633,7 @@ class NodePool
 
   struct Block
   {
-    // We create and destroy Block using NS_Alloc/NS_Free rather
+    // We create and destroy Block using moz_xmalloc/free rather
     // than new and delete to avoid calling its constructor and
     // destructor.
     Block()
@@ -673,7 +673,7 @@ class NodePool
     Block* b = mBlocks;
     while (b) {
       Block* n = b->mNext;
-      NS_Free(b);
+      free(b);
       b = n;
     }
 
@@ -703,7 +703,7 @@ class NodePool
     PtrInfo* Add(void* aPointer, nsCycleCollectionParticipant* aParticipant)
     {
       if (mNext == mBlockEnd) {
-        Block* block = static_cast<Block*>(NS_Alloc(sizeof(Block)));
+        Block* block = static_cast<Block*>(moz_xmalloc(sizeof(Block)));
         *mNextBlock = block;
         mNext = block->mEntries;
         mBlockEnd = block->mEntries + BlockSize;
diff --git a/xpcom/base/nsIMemory.idl b/xpcom/base/nsIMemory.idl
index a474a5b29097..c49e34f3c9bd 100644
--- a/xpcom/base/nsIMemory.idl
+++ b/xpcom/base/nsIMemory.idl
@@ -10,7 +10,7 @@
  * nsIMemory: interface to allocate and deallocate memory. Also provides
  * for notifications in low-memory situations.
  *
- * The frozen exported symbols NS_Alloc, NS_Realloc, and NS_Free
+ * The frozen exported symbols moz_xmalloc, moz_xrealloc, and free
  * provide a more efficient way to access XPCOM memory allocation. Using
  * those symbols is preferred to using the methods on this interface.
  *
diff --git a/xpcom/base/nsMemoryImpl.cpp b/xpcom/base/nsMemoryImpl.cpp
index 0d619a37c1c0..bf9eb98c7e62 100644
--- a/xpcom/base/nsMemoryImpl.cpp
+++ b/xpcom/base/nsMemoryImpl.cpp
@@ -185,24 +185,6 @@ nsMemoryImpl::sLastFlushTime = 0;
 nsMemoryImpl::FlushEvent
 nsMemoryImpl::sFlushEvent;
 
-XPCOM_API(void*)
-NS_Alloc(size_t aSize)
-{
-  return moz_xmalloc(aSize);
-}
-
-XPCOM_API(void*)
-NS_Realloc(void* aPtr, size_t aSize)
-{
-  return moz_xrealloc(aPtr, aSize);
-}
-
-XPCOM_API(void)
-NS_Free(void* aPtr)
-{
-  free(aPtr);
-}
-
 nsresult
 NS_GetMemoryManager(nsIMemory** aResult)
 {
diff --git a/xpcom/base/nsUUIDGenerator.cpp b/xpcom/base/nsUUIDGenerator.cpp
index 2419a8273def..254a013227db 100644
--- a/xpcom/base/nsUUIDGenerator.cpp
+++ b/xpcom/base/nsUUIDGenerator.cpp
@@ -84,14 +84,14 @@ nsUUIDGenerator::Init()
 NS_IMETHODIMP
 nsUUIDGenerator::GenerateUUID(nsID** aRet)
 {
-  nsID* id = static_cast<nsID*>(NS_Alloc(sizeof(nsID)));
+  nsID* id = static_cast<nsID*>(moz_xmalloc(sizeof(nsID)));
   if (!id) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   nsresult rv = GenerateUUIDInPlace(id);
   if (NS_FAILED(rv)) {
-    NS_Free(id);
+    free(id);
     return rv;
   }
 
diff --git a/xpcom/build/FrozenFunctions.cpp b/xpcom/build/FrozenFunctions.cpp
index 75996a9cb8b7..8a957ca45f5e 100644
--- a/xpcom/build/FrozenFunctions.cpp
+++ b/xpcom/build/FrozenFunctions.cpp
@@ -62,9 +62,9 @@ static const XPCOMFunctions kFrozenFunctions = {
   &NS_CStringCloneData,
 
   // these functions were added post 1.7 (post Firefox 1.0)
-  &NS_Alloc,
-  &NS_Realloc,
-  &NS_Free,
+  &moz_xmalloc,
+  &moz_xrealloc,
+  &free,
   &NS_StringContainerInit2,
   &NS_CStringContainerInit2,
   &NS_StringGetMutableData,
diff --git a/xpcom/build/PoisonIOInterposerMac.cpp b/xpcom/build/PoisonIOInterposerMac.cpp
index d1743614ea0a..7b26156c2107 100644
--- a/xpcom/build/PoisonIOInterposerMac.cpp
+++ b/xpcom/build/PoisonIOInterposerMac.cpp
@@ -86,7 +86,7 @@ class MacIOAutoObservation : public IOInterposeObserver::Observation
   {
     Report();
     if (mFilename) {
-      NS_Free(mFilename);
+      free(mFilename);
       mFilename = nullptr;
     }
   }
diff --git a/xpcom/build/PoisonIOInterposerWin.cpp b/xpcom/build/PoisonIOInterposerWin.cpp
index 1313da17428c..83aa0168242f 100644
--- a/xpcom/build/PoisonIOInterposerWin.cpp
+++ b/xpcom/build/PoisonIOInterposerWin.cpp
@@ -180,7 +180,7 @@ class WinIOAutoObservation : public IOInterposeObserver::Observation
     Report();
     if (mFilename) {
       MOZ_ASSERT(mHasQueriedFilename);
-      NS_Free(mFilename);
+      free(mFilename);
       mFilename = nullptr;
     }
   }
diff --git a/xpcom/build/XPCOMInit.cpp b/xpcom/build/XPCOMInit.cpp
index 4da014968ac4..b5bd793eab96 100644
--- a/xpcom/build/XPCOMInit.cpp
+++ b/xpcom/build/XPCOMInit.cpp
@@ -917,7 +917,7 @@ ShutdownXPCOM(nsIServiceManager* aServMgr)
   // Release the directory service
   NS_IF_RELEASE(nsDirectoryService::gService);
 
-  NS_Free(gGREBinPath);
+  free(gGREBinPath);
   gGREBinPath = nullptr;
 
   if (moduleLoaders) {
diff --git a/xpcom/build/nsXPCOM.h b/xpcom/build/nsXPCOM.h
index 39c73a79f008..17e4a6b79fa1 100644
--- a/xpcom/build/nsXPCOM.h
+++ b/xpcom/build/nsXPCOM.h
@@ -162,6 +162,12 @@ XPCOM_API(nsresult) NS_NewNativeLocalFile(const nsACString& aPath,
 
 #endif
 
+/**
+ * Allocator functions for the standalone glue.
+ * Do not use outside the xpcom glue code.
+ * Use moz_xmalloc/moz_xrealloc/free, or new/delete instead.
+ */
+#ifdef XPCOM_GLUE
 /**
  * Allocates a block of memory of a particular size. If the memory cannot
  * be allocated (because of an out-of-memory condition), the process aborts.
@@ -198,6 +204,11 @@ XPCOM_API(void*) NS_Realloc(void* aPtr, size_t aSize);
  * @note        This function is thread-safe.
  */
 XPCOM_API(void) NS_Free(void* aPtr);
+#else
+#define NS_Alloc moz_xmalloc
+#define NS_Realloc moz_xrealloc
+#define NS_Free free
+#endif
 
 /**
  * Support for warnings, assertions, and debugging breaks.
diff --git a/xpcom/build/nsXREAppData.h b/xpcom/build/nsXREAppData.h
index 0f09a3eb008f..9cabfdec08e7 100644
--- a/xpcom/build/nsXREAppData.h
+++ b/xpcom/build/nsXREAppData.h
@@ -16,7 +16,7 @@ class nsIFile;
  * Application-specific data needed to start the apprunner.
  *
  * @note When this structure is allocated and manipulated by XRE_CreateAppData,
- *       string fields will be allocated with NS_Alloc, and interface pointers
+ *       string fields will be allocated with moz_xmalloc, and interface pointers
  *       are strong references.
  */
 struct nsXREAppData
diff --git a/xpcom/components/nsCategoryManager.cpp b/xpcom/components/nsCategoryManager.cpp
index 729c45ba3b9d..2ef8d923d3a9 100644
--- a/xpcom/components/nsCategoryManager.cpp
+++ b/xpcom/components/nsCategoryManager.cpp
@@ -695,7 +695,7 @@ nsCategoryManager::AddCategoryEntry(const char* aCategoryName,
     if (aOldValue) {
       *aOldValue = oldEntry;
     } else {
-      NS_Free(oldEntry);
+      free(oldEntry);
     }
   }
 }
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
index f07a1bcc6af3..11c297d12e3c 100644
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -1036,7 +1036,7 @@ nsComponentManagerImpl::GetClassObject(const nsCID& aClass, const nsIID& aIID,
     char* buf = aClass.ToString();
     PR_LogPrint("nsComponentManager: GetClassObject(%s)", buf);
     if (buf) {
-      NS_Free(buf);
+      free(buf);
     }
   }
 #endif
@@ -1160,7 +1160,7 @@ nsComponentManagerImpl::CreateInstance(const nsCID& aClass,
            ("nsComponentManager: CreateInstance(%s) %s", buf,
             NS_SUCCEEDED(rv) ? "succeeded" : "FAILED"));
     if (buf) {
-      NS_Free(buf);
+      free(buf);
     }
   }
 #endif
@@ -1832,7 +1832,7 @@ nsComponentManagerImpl::ContractIDToCID(const char* aContractID,
     SafeMutexAutoLock lock(mLock);
     nsFactoryEntry* entry = mContractIDs.Get(nsDependentCString(aContractID));
     if (entry) {
-      *aResult = (nsCID*)NS_Alloc(sizeof(nsCID));
+      *aResult = (nsCID*)moz_xmalloc(sizeof(nsCID));
       **aResult = *entry->mCIDEntry->cid;
       return NS_OK;
     }
diff --git a/xpcom/ds/nsVariant.cpp b/xpcom/ds/nsVariant.cpp
index 2de49ffc5155..b7ad2d05de83 100644
--- a/xpcom/ds/nsVariant.cpp
+++ b/xpcom/ds/nsVariant.cpp
@@ -1561,7 +1561,7 @@ nsVariant::AllocateWStringWithSize(nsDiscriminatedUnion* aData, uint32_t aSize)
 {
   DATA_SETTER_PROLOGUE(aData);
   if (!(aData->u.wstr.mWStringValue =
-          (char16_t*)NS_Alloc((aSize + 1) * sizeof(char16_t)))) {
+          (char16_t*)moz_xmalloc((aSize + 1) * sizeof(char16_t)))) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
   aData->u.wstr.mWStringValue[aSize] = '\0';
diff --git a/xpcom/io/nsBinaryStream.cpp b/xpcom/io/nsBinaryStream.cpp
index 88390fb61834..e42722ee4c13 100644
--- a/xpcom/io/nsBinaryStream.cpp
+++ b/xpcom/io/nsBinaryStream.cpp
@@ -315,7 +315,7 @@ nsBinaryOutputStream::WriteCompoundObject(nsISupports* aObject,
 
     rv = WriteID(*cidptr);
 
-    NS_Free(cidptr);
+    free(cidptr);
   }
 
   if (NS_WARN_IF(NS_FAILED(rv))) {
diff --git a/xpcom/io/nsEscape.cpp b/xpcom/io/nsEscape.cpp
index 2a9698458b58..ca64d93731d2 100644
--- a/xpcom/io/nsEscape.cpp
+++ b/xpcom/io/nsEscape.cpp
@@ -104,9 +104,6 @@ nsEscapeCount(const char* aStr, nsEscapeMask aFlags, size_t* aOutLen)
   }
 
   // fail if we need more than 4GB
-  // size_t is likely to be long unsigned int but moz_xmalloc(size_t)
-  // calls NS_Alloc_P(size_t) which calls PR_Malloc(uint32_t), so there is
-  // no chance to allocate more than 4GB using moz_xmalloc()
   if (dstSize > UINT32_MAX) {
     return 0;
   }
@@ -233,7 +230,7 @@ nsEscapeHTML(const char* aString)
     return nullptr;
   }
 
-  rv = (char*)NS_Alloc((6 * len) + 1);
+  rv = (char*)moz_xmalloc((6 * len) + 1);
   char* ptr = rv;
 
   if (rv) {
diff --git a/xpcom/io/nsWildCard.cpp b/xpcom/io/nsWildCard.cpp
index 51789234be2c..9b8ab8112b50 100644
--- a/xpcom/io/nsWildCard.cpp
+++ b/xpcom/io/nsWildCard.cpp
@@ -240,7 +240,7 @@ _handle_union(const T* aStr, const T* aExpr, bool aCaseInsensitive,
     return ABORTED;
   }
   ++cp;                /* now index of char after closing parenthesis */
-  e2 = (T*)NS_Alloc((1 + nsCharTraits<T>::length(aExpr)) * sizeof(T));
+  e2 = (T*)moz_xmalloc((1 + nsCharTraits<T>::length(aExpr)) * sizeof(T));
   if (!e2) {
     return ABORTED;
   }
@@ -261,7 +261,7 @@ _handle_union(const T* aStr, const T* aExpr, bool aCaseInsensitive,
       break;
     }
   }
-  NS_Free(e2);
+  free(e2);
   if (sx < 2) {
     ret = ABORTED;
   }
@@ -426,7 +426,7 @@ ns_WildCardMatch(const T* aStr, const T* aXp, bool aCaseInsensitive)
     return ::_shexp_match(aStr, aXp, aCaseInsensitive, 0);
   }
 
-  expr = (T*)NS_Alloc((nsCharTraits<T>::length(aXp) + 1) * sizeof(T));
+  expr = (T*)moz_xmalloc((nsCharTraits<T>::length(aXp) + 1) * sizeof(T));
   if (!expr) {
     return NOMATCH;
   }
@@ -451,7 +451,7 @@ ns_WildCardMatch(const T* aStr, const T* aXp, bool aCaseInsensitive)
     ret = ::_shexp_match(aStr, expr, aCaseInsensitive, 0);
   }
 
-  NS_Free(expr);
+  free(expr);
   return ret;
 }
 
diff --git a/xpcom/string/nsTString.h b/xpcom/string/nsTString.h
index 54ee1e2a0ed3..757fda7689da 100644
--- a/xpcom/string/nsTString.h
+++ b/xpcom/string/nsTString.h
@@ -700,7 +700,7 @@ class nsTArrayElementTraits<nsTAutoString_CharT>
  *   (1) mData can be null
  *   (2) objects of this type can be automatically cast to |const CharT*|
  *   (3) getter_Copies method is supported to adopt data allocated with
- *       NS_Alloc, such as "out string" parameters in XPIDL.
+ *       moz_xmalloc, such as "out string" parameters in XPIDL.
  *
  * NAMES:
  *   nsXPIDLString for wide characters
diff --git a/xpcom/tests/external/TestMinStringAPI.cpp b/xpcom/tests/external/TestMinStringAPI.cpp
index cd0880a73943..e93a9a9173b1 100644
--- a/xpcom/tests/external/TestMinStringAPI.cpp
+++ b/xpcom/tests/external/TestMinStringAPI.cpp
@@ -50,7 +50,7 @@ static bool test_basic_1()
         NS_ERROR("unexpected result");
         return false;
       }
-    NS_Free(clone);
+    free(clone);
 
     nsCStringContainer temp;
     NS_CStringContainerInit(temp);
@@ -109,7 +109,7 @@ static bool test_basic_2()
         NS_ERROR("unexpected result");
         return false;
       }
-    NS_Free(clone);
+    free(clone);
 
     nsStringContainer temp;
     NS_StringContainerInit(temp);
diff --git a/xpcom/tests/gtest/TestEncoding.cpp b/xpcom/tests/gtest/TestEncoding.cpp
index 1f6f7a2b6274..0671284ee240 100644
--- a/xpcom/tests/gtest/TestEncoding.cpp
+++ b/xpcom/tests/gtest/TestEncoding.cpp
@@ -30,7 +30,7 @@ TEST(Encoding, GoodSurrogatePair)
   nsDependentCString expected((const char*)expected8);
   EXPECT_EQ(0, CompareUTF8toUTF16(expected, goodPair16));
 
-  NS_Free(goodPair8);
+  free(goodPair8);
 }
 
 TEST(Encoding, BackwardsSurrogatePair)
@@ -55,7 +55,7 @@ TEST(Encoding, BackwardsSurrogatePair)
   nsDependentCString expected((const char*)expected8);
   EXPECT_EQ(0, CompareUTF8toUTF16(expected, backwardsPair16));
 
-  NS_Free(backwardsPair8);
+  free(backwardsPair8);
 }
 
 TEST(Encoding, MalformedUTF16OrphanHighSurrogate)
@@ -80,7 +80,7 @@ TEST(Encoding, MalformedUTF16OrphanHighSurrogate)
   nsDependentCString expected((const char*)expected8);
   EXPECT_EQ(0, CompareUTF8toUTF16(expected, highSurrogate16));
 
-  NS_Free(highSurrogate8);
+  free(highSurrogate8);
 }
 
 TEST(Encoding, MalformedUTF16OrphanLowSurrogate)
@@ -105,5 +105,5 @@ TEST(Encoding, MalformedUTF16OrphanLowSurrogate)
   nsDependentCString expected((const char*)expected8);
   EXPECT_EQ(0, CompareUTF8toUTF16(expected, lowSurrogate16));
 
-  NS_Free(lowSurrogate8);
+  free(lowSurrogate8);
 }
diff --git a/xpcom/threads/nsProcessCommon.cpp b/xpcom/threads/nsProcessCommon.cpp
index 0ce2e1eb282d..c9dee675d4e7 100644
--- a/xpcom/threads/nsProcessCommon.cpp
+++ b/xpcom/threads/nsProcessCommon.cpp
@@ -364,7 +364,7 @@ nsProcess::CopyArgsAndRunProcess(bool aBlocking, const char** aArgs,
 {
   // Add one to the aCount for the program name and one for null termination.
   char** my_argv = nullptr;
-  my_argv = (char**)NS_Alloc(sizeof(char*) * (aCount + 2));
+  my_argv = (char**)moz_xmalloc(sizeof(char*) * (aCount + 2));
   if (!my_argv) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -379,8 +379,8 @@ nsProcess::CopyArgsAndRunProcess(bool aBlocking, const char** aArgs,
 
   nsresult rv = RunProcess(aBlocking, my_argv, aObserver, aHoldWeak, false);
 
-  NS_Free(my_argv[0]);
-  NS_Free(my_argv);
+  free(my_argv[0]);
+  free(my_argv);
   return rv;
 }
 
@@ -406,7 +406,7 @@ nsProcess::CopyArgsAndRunProcessw(bool aBlocking, const char16_t** aArgs,
 {
   // Add one to the aCount for the program name and one for null termination.
   char** my_argv = nullptr;
-  my_argv = (char**)NS_Alloc(sizeof(char*) * (aCount + 2));
+  my_argv = (char**)moz_xmalloc(sizeof(char*) * (aCount + 2));
   if (!my_argv) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
@@ -422,9 +422,9 @@ nsProcess::CopyArgsAndRunProcessw(bool aBlocking, const char16_t** aArgs,
   nsresult rv = RunProcess(aBlocking, my_argv, aObserver, aHoldWeak, true);
 
   for (uint32_t i = 0; i <= aCount; ++i) {
-    NS_Free(my_argv[i]);
+    free(my_argv[i]);
   }
-  NS_Free(my_argv);
+  free(my_argv);
   return rv;
 }
 
