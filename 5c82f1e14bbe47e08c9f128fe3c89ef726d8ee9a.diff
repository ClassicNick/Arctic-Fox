diff --git a/js/src/jit/shared/Assembler-x86-shared.h b/js/src/jit/shared/Assembler-x86-shared.h
index 12fc2490f1de..9f542c460c5c 100644
--- a/js/src/jit/shared/Assembler-x86-shared.h
+++ b/js/src/jit/shared/Assembler-x86-shared.h
@@ -1105,12 +1105,6 @@ class AssemblerX86Shared : public AssemblerShared
             MOZ_CRASH("unexpected operand kind");
         }
     }
-    // Note, lock_addl() is used for a memory barrier on non-SSE2 systems.
-    // Do not optimize, replace by XADDL, or similar.
-    void lock_addl(Imm32 imm, const Operand &op) {
-        masm.prefix_lock();
-        addl(imm, op);
-    }
     void subl(Imm32 imm, Register dest) {
         masm.subl_ir(imm.value, dest.code());
     }
@@ -1129,6 +1123,21 @@ class AssemblerX86Shared : public AssemblerShared
     void addl(Register src, Register dest) {
         masm.addl_rr(src.code(), dest.code());
     }
+    void addl(Register src, const Operand &dest) {
+        switch (dest.kind()) {
+          case Operand::REG:
+            masm.addl_rr(src.code(), dest.reg());
+            break;
+          case Operand::MEM_REG_DISP:
+            masm.addl_rm(src.code(), dest.disp(), dest.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.addl_rm(src.code(), dest.disp(), dest.base(), dest.index(), dest.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+        }
+    }
     void subl(Register src, Register dest) {
         masm.subl_rr(src.code(), dest.code());
     }
@@ -1152,6 +1161,9 @@ class AssemblerX86Shared : public AssemblerShared
           case Operand::MEM_REG_DISP:
             masm.subl_rm(src.code(), dest.disp(), dest.base());
             break;
+          case Operand::MEM_SCALE:
+            masm.subl_rm(src.code(), dest.disp(), dest.base(), dest.index(), dest.scale());
+            break;
           default:
             MOZ_CRASH("unexpected operand kind");
         }
@@ -1159,6 +1171,21 @@ class AssemblerX86Shared : public AssemblerShared
     void orl(Register reg, Register dest) {
         masm.orl_rr(reg.code(), dest.code());
     }
+    void orl(Register src, const Operand &dest) {
+        switch (dest.kind()) {
+          case Operand::REG:
+            masm.orl_rr(src.code(), dest.reg());
+            break;
+          case Operand::MEM_REG_DISP:
+            masm.orl_rm(src.code(), dest.disp(), dest.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.orl_rm(src.code(), dest.disp(), dest.base(), dest.index(), dest.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+        }
+    }
     void orl(Imm32 imm, Register reg) {
         masm.orl_ir(imm.value, reg.code());
     }
@@ -1177,6 +1204,21 @@ class AssemblerX86Shared : public AssemblerShared
     void xorl(Register src, Register dest) {
         masm.xorl_rr(src.code(), dest.code());
     }
+    void xorl(Register src, const Operand &dest) {
+        switch (dest.kind()) {
+          case Operand::REG:
+            masm.xorl_rr(src.code(), dest.reg());
+            break;
+          case Operand::MEM_REG_DISP:
+            masm.xorl_rm(src.code(), dest.disp(), dest.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.xorl_rm(src.code(), dest.disp(), dest.base(), dest.index(), dest.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+        }
+    }
     void xorl(Imm32 imm, Register reg) {
         masm.xorl_ir(imm.value, reg.code());
     }
@@ -1195,6 +1237,21 @@ class AssemblerX86Shared : public AssemblerShared
     void andl(Register src, Register dest) {
         masm.andl_rr(src.code(), dest.code());
     }
+    void andl(Register src, const Operand &dest) {
+        switch (dest.kind()) {
+          case Operand::REG:
+            masm.andl_rr(src.code(), dest.reg());
+            break;
+          case Operand::MEM_REG_DISP:
+            masm.andl_rm(src.code(), dest.disp(), dest.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.andl_rm(src.code(), dest.disp(), dest.base(), dest.index(), dest.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+        }
+    }
     void andl(Imm32 imm, Register dest) {
         masm.andl_ir(imm.value, dest.code());
     }
@@ -1362,40 +1419,260 @@ class AssemblerX86Shared : public AssemblerShared
         decl(op);
     }
 
-    void lock_cmpxchg8(Register src, const Operand &mem) {
+    void addb(Imm32 imm, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.addb_im(imm.value, op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.addb_im(imm.value, op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+    void addb(Register src, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.addb_rm(src.code(), op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.addb_rm(src.code(), op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+
+    void subb(Imm32 imm, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.subb_im(imm.value, op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.subb_im(imm.value, op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+    void subb(Register src, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.subb_rm(src.code(), op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.subb_rm(src.code(), op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+
+    void andb(Imm32 imm, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.andb_im(imm.value, op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.andb_im(imm.value, op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+    void andb(Register src, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.andb_rm(src.code(), op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.andb_rm(src.code(), op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+
+    void orb(Imm32 imm, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.orb_im(imm.value, op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.orb_im(imm.value, op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+    void orb(Register src, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.orb_rm(src.code(), op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.orb_rm(src.code(), op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+
+    void xorb(Imm32 imm, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.xorb_im(imm.value, op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.xorb_im(imm.value, op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+    void xorb(Register src, const Operand &op) {
+        switch (op.kind()) {
+          case Operand::MEM_REG_DISP:
+            masm.xorb_rm(src.code(), op.disp(), op.base());
+            break;
+          case Operand::MEM_SCALE:
+            masm.xorb_rm(src.code(), op.disp(), op.base(), op.index(), op.scale());
+            break;
+          default:
+            MOZ_CRASH("unexpected operand kind");
+            break;
+        }
+    }
+
+    template<typename T>
+    void lock_addb(T src, const Operand &op) {
+        masm.prefix_lock();
+        addb(src, op);
+    }
+    template<typename T>
+    void lock_subb(T src, const Operand &op) {
+        masm.prefix_lock();
+        subb(src, op);
+    }
+    template<typename T>
+    void lock_andb(T src, const Operand &op) {
+        masm.prefix_lock();
+        andb(src, op);
+    }
+    template<typename T>
+    void lock_orb(T src, const Operand &op) {
+        masm.prefix_lock();
+        orb(src, op);
+    }
+    template<typename T>
+    void lock_xorb(T src, const Operand &op) {
+        masm.prefix_lock();
+        xorb(src, op);
+    }
+
+    template<typename T>
+    void lock_addw(T src, const Operand &op) {
+        masm.prefix_lock();
+        masm.prefix_16_for_32();
+        addl(src, op);
+    }
+    template<typename T>
+    void lock_subw(T src, const Operand &op) {
+        masm.prefix_lock();
+        masm.prefix_16_for_32();
+        subl(src, op);
+    }
+    template<typename T>
+    void lock_andw(T src, const Operand &op) {
+        masm.prefix_lock();
+        masm.prefix_16_for_32();
+        andl(src, op);
+    }
+    template<typename T>
+    void lock_orw(T src, const Operand &op) {
+        masm.prefix_lock();
+        masm.prefix_16_for_32();
+        orl(src, op);
+    }
+    template<typename T>
+    void lock_xorw(T src, const Operand &op) {
+        masm.prefix_lock();
+        masm.prefix_16_for_32();
+        xorl(src, op);
+    }
+
+    // Note, lock_addl(imm, op) is used for a memory barrier on non-SSE2 systems,
+    // among other things.  Do not optimize, replace by XADDL, or similar.
+    template<typename T>
+    void lock_addl(T src, const Operand &op) {
+        masm.prefix_lock();
+        addl(src, op);
+    }
+    template<typename T>
+    void lock_subl(T src, const Operand &op) {
+        masm.prefix_lock();
+        subl(src, op);
+    }
+    template<typename T>
+    void lock_andl(T src, const Operand &op) {
+        masm.prefix_lock();
+        andl(src, op);
+    }
+    template<typename T>
+    void lock_orl(T src, const Operand &op) {
+        masm.prefix_lock();
+        orl(src, op);
+    }
+    template<typename T>
+    void lock_xorl(T src, const Operand &op) {
+        masm.prefix_lock();
+        xorl(src, op);
+    }
+
+    void lock_cmpxchgb(Register src, const Operand &mem) {
         masm.prefix_lock();
         switch (mem.kind()) {
           case Operand::MEM_REG_DISP:
-            masm.cmpxchg8(src.code(), mem.disp(), mem.base());
+            masm.cmpxchgb(src.code(), mem.disp(), mem.base());
             break;
           case Operand::MEM_SCALE:
-            masm.cmpxchg8(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
+            masm.cmpxchgb(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
             break;
           default:
             MOZ_CRASH("unexpected operand kind");
         }
     }
-    void lock_cmpxchg16(Register src, const Operand &mem) {
+    void lock_cmpxchgw(Register src, const Operand &mem) {
         masm.prefix_lock();
         switch (mem.kind()) {
           case Operand::MEM_REG_DISP:
-            masm.cmpxchg16(src.code(), mem.disp(), mem.base());
+            masm.cmpxchgw(src.code(), mem.disp(), mem.base());
             break;
           case Operand::MEM_SCALE:
-            masm.cmpxchg16(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
+            masm.cmpxchgw(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
             break;
           default:
             MOZ_CRASH("unexpected operand kind");
         }
     }
-    void lock_cmpxchg32(Register src, const Operand &mem) {
+    void lock_cmpxchgl(Register src, const Operand &mem) {
         masm.prefix_lock();
         switch (mem.kind()) {
           case Operand::MEM_REG_DISP:
-            masm.cmpxchg32(src.code(), mem.disp(), mem.base());
+            masm.cmpxchgl(src.code(), mem.disp(), mem.base());
             break;
           case Operand::MEM_SCALE:
-            masm.cmpxchg32(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
+            masm.cmpxchgl(src.code(), mem.disp(), mem.base(), mem.index(), mem.scale());
             break;
           default:
             MOZ_CRASH("unexpected operand kind");
diff --git a/js/src/jit/shared/BaseAssembler-x86-shared.h b/js/src/jit/shared/BaseAssembler-x86-shared.h
index 2490beeff3ce..cba821b388c5 100644
--- a/js/src/jit/shared/BaseAssembler-x86-shared.h
+++ b/js/src/jit/shared/BaseAssembler-x86-shared.h
@@ -288,6 +288,12 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_ADD_EvGv, offset, base, src);
     }
 
+    void addl_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("addl       %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_ADD_EvGv, offset, base, index, scale, src);
+    }
+
     void addl_ir(int32_t imm, RegisterID dst)
     {
         spew("addl       $%d, %s", imm, GPReg32Name(dst));
@@ -395,18 +401,138 @@ class BaseAssembler : public GenericAssembler {
         }
     }
 
+    void addb_im(int32_t imm, int32_t offset, RegisterID base) {
+        spew("addb       $%d, " MEM_ob, int8_t(imm), ADDR_ob(offset, base));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, GROUP1_OP_ADD);
+        m_formatter.immediate8(imm);
+    }
+
+    void addb_im(int32_t imm, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("addb       $%d, " MEM_obs, int8_t(imm), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, index, scale, GROUP1_OP_ADD);
+        m_formatter.immediate8(imm);
+    }
+
+    void addb_rm(RegisterID src, int32_t offset, RegisterID base) {
+        spew("addb       %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.oneByteOp8(OP_ADD_EbGb, offset, base, src);
+    }
+
+    void addb_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("addb       %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp8(OP_ADD_EbGb, offset, base, index, scale, src);
+    }
+
+    void subb_im(int32_t imm, int32_t offset, RegisterID base) {
+        spew("subb       $%d, " MEM_ob, int8_t(imm), ADDR_ob(offset, base));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, GROUP1_OP_SUB);
+        m_formatter.immediate8(imm);
+    }
+
+    void subb_im(int32_t imm, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("subb       $%d, " MEM_obs, int8_t(imm), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, index, scale, GROUP1_OP_SUB);
+        m_formatter.immediate8(imm);
+    }
+
+    void subb_rm(RegisterID src, int32_t offset, RegisterID base) {
+        spew("subb       %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.oneByteOp8(OP_SUB_EbGb, offset, base, src);
+    }
+
+    void subb_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("subb       %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp8(OP_SUB_EbGb, offset, base, index, scale, src);
+    }
+
+    void andb_im(int32_t imm, int32_t offset, RegisterID base) {
+        spew("andb       $%d, " MEM_ob, int8_t(imm), ADDR_ob(offset, base));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, GROUP1_OP_AND);
+        m_formatter.immediate8(imm);
+    }
+
+    void andb_im(int32_t imm, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("andb       $%d, " MEM_obs, int8_t(imm), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, index, scale, GROUP1_OP_AND);
+        m_formatter.immediate8(imm);
+    }
+
+    void andb_rm(RegisterID src, int32_t offset, RegisterID base) {
+        spew("andb       %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.oneByteOp8(OP_AND_EbGb, offset, base, src);
+    }
+
+    void andb_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("andb       %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp8(OP_AND_EbGb, offset, base, index, scale, src);
+    }
+
+    void orb_im(int32_t imm, int32_t offset, RegisterID base) {
+        spew("orb       $%d, " MEM_ob, int8_t(imm), ADDR_ob(offset, base));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, GROUP1_OP_OR);
+        m_formatter.immediate8(imm);
+    }
+
+    void orb_im(int32_t imm, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("orb        $%d, " MEM_obs, int8_t(imm), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, index, scale, GROUP1_OP_OR);
+        m_formatter.immediate8(imm);
+    }
+
+    void orb_rm(RegisterID src, int32_t offset, RegisterID base) {
+        spew("orb       %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.oneByteOp8(OP_OR_EbGb, offset, base, src);
+    }
+
+    void orb_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("orb        %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp8(OP_OR_EbGb, offset, base, index, scale, src);
+    }
+
+    void xorb_im(int32_t imm, int32_t offset, RegisterID base) {
+        spew("xorb       $%d, " MEM_ob, int8_t(imm), ADDR_ob(offset, base));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, GROUP1_OP_XOR);
+        m_formatter.immediate8(imm);
+    }
+
+    void xorb_im(int32_t imm, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("xorb       $%d, " MEM_obs, int8_t(imm), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_GROUP1_EbIb, offset, base, index, scale, GROUP1_OP_XOR);
+        m_formatter.immediate8(imm);
+    }
+
+    void xorb_rm(RegisterID src, int32_t offset, RegisterID base) {
+        spew("xorb       %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.oneByteOp8(OP_XOR_EbGb, offset, base, src);
+    }
+
+    void xorb_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("xorb       %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp8(OP_XOR_EbGb, offset, base, index, scale, src);
+    }
+
     void lock_xaddb_rm(RegisterID srcdest, int32_t offset, RegisterID base)
     {
-        spew("lock xaddl %s, " MEM_ob, GPReg8Name(srcdest), ADDR_ob(offset, base));
+        spew("lock xaddb %s, " MEM_ob, GPReg8Name(srcdest), ADDR_ob(offset, base));
         m_formatter.oneByteOp(PRE_LOCK);
-        m_formatter.twoByteOp(OP2_XADD_EbGb, offset, base, srcdest);
+        m_formatter.twoByteOp8(OP2_XADD_EbGb, offset, base, srcdest);
     }
 
     void lock_xaddb_rm(RegisterID srcdest, int32_t offset, RegisterID base, RegisterID index, int scale)
     {
-        spew("lock xaddl %s, " MEM_obs, GPReg8Name(srcdest), ADDR_obs(offset, base, index, scale));
+        spew("lock xaddb %s, " MEM_obs, GPReg8Name(srcdest), ADDR_obs(offset, base, index, scale));
         m_formatter.oneByteOp(PRE_LOCK);
-        m_formatter.twoByteOp(OP2_XADD_EbGb, offset, base, index, scale, srcdest);
+        m_formatter.twoByteOp8(OP2_XADD_EbGb, offset, base, index, scale, srcdest);
     }
 
     void lock_xaddl_rm(RegisterID srcdest, int32_t offset, RegisterID base)
@@ -567,6 +693,12 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_AND_EvGv, offset, base, src);
     }
 
+    void andl_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("andl       %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_AND_EvGv, offset, base, index, scale, src);
+    }
+
     void andl_ir(int32_t imm, RegisterID dst)
     {
         spew("andl       $0x%x, %s", imm, GPReg32Name(dst));
@@ -727,6 +859,12 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_OR_EvGv, offset, base, src);
     }
 
+    void orl_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("orl        %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_OR_EvGv, offset, base, index, scale, src);
+    }
+
     void orl_ir(int32_t imm, RegisterID dst)
     {
         spew("orl        $0x%x, %s", imm, GPReg32Name(dst));
@@ -819,6 +957,12 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_SUB_EvGv, offset, base, src);
     }
 
+    void subl_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("subl       %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_SUB_EvGv, offset, base, index, scale, src);
+    }
+
     void subl_ir(int32_t imm, RegisterID dst)
     {
         spew("subl       $%d, %s", imm, GPReg32Name(dst));
@@ -917,6 +1061,12 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_XOR_EvGv, offset, base, src);
     }
 
+    void xorl_rm(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    {
+        spew("xorl       %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.oneByteOp(OP_XOR_EvGv, offset, base, index, scale, src);
+    }
+
     void xorl_im(int32_t imm, int32_t offset, RegisterID base)
     {
         spew("xorl       $0x%x, " MEM_ob, imm, ADDR_ob(offset, base));
@@ -1136,41 +1286,41 @@ class BaseAssembler : public GenericAssembler {
         m_formatter.oneByteOp(OP_GROUP5_Ev, offset, base, GROUP5_OP_DEC);
     }
 
-    // Note that CMPXCHG performs comparison against REG = %al/%ax/%eax.
+    // Note that CMPXCHG performs comparison against REG = %al/%ax/%eax/%rax.
     // If %REG == [%base+offset], then %src -> [%base+offset].
     // Otherwise, [%base+offset] -> %REG.
     // For the 8-bit operations src must also be an 8-bit register.
 
-    void cmpxchg8(RegisterID src, int32_t offset, RegisterID base)
+    void cmpxchgb(RegisterID src, int32_t offset, RegisterID base)
     {
-        spew("cmpxchg8   %s, " MEM_ob, GPRegName(src), ADDR_ob(offset, base));
-        m_formatter.twoByteOp(OP2_CMPXCHG_GvEb, offset, base, src);
+        spew("cmpxchgb   %s, " MEM_ob, GPReg8Name(src), ADDR_ob(offset, base));
+        m_formatter.twoByteOp8(OP2_CMPXCHG_GvEb, offset, base, src);
     }
-    void cmpxchg8(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    void cmpxchgb(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
     {
-        spew("cmpxchg8   %s, " MEM_obs, GPRegName(src), ADDR_obs(offset, base, index, scale));
-        m_formatter.twoByteOp(OP2_CMPXCHG_GvEb, offset, base, index, scale, src);
+        spew("cmpxchgb   %s, " MEM_obs, GPReg8Name(src), ADDR_obs(offset, base, index, scale));
+        m_formatter.twoByteOp8(OP2_CMPXCHG_GvEb, offset, base, index, scale, src);
     }
-    void cmpxchg16(RegisterID src, int32_t offset, RegisterID base)
+    void cmpxchgw(RegisterID src, int32_t offset, RegisterID base)
     {
-        spew("cmpxchg16  %s, " MEM_ob, GPRegName(src), ADDR_ob(offset, base));
+        spew("cmpxchgw   %s, " MEM_ob, GPReg16Name(src), ADDR_ob(offset, base));
         m_formatter.prefix(PRE_OPERAND_SIZE);
         m_formatter.twoByteOp(OP2_CMPXCHG_GvEw, offset, base, src);
     }
-    void cmpxchg16(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    void cmpxchgw(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
     {
-        spew("cmpxchg16  %s, " MEM_obs, GPRegName(src), ADDR_obs(offset, base, index, scale));
+        spew("cmpxchgw   %s, " MEM_obs, GPReg16Name(src), ADDR_obs(offset, base, index, scale));
         m_formatter.prefix(PRE_OPERAND_SIZE);
         m_formatter.twoByteOp(OP2_CMPXCHG_GvEw, offset, base, index, scale, src);
     }
-    void cmpxchg32(RegisterID src, int32_t offset, RegisterID base)
+    void cmpxchgl(RegisterID src, int32_t offset, RegisterID base)
     {
-        spew("cmpxchg32  %s, " MEM_ob, GPRegName(src), ADDR_ob(offset, base));
+        spew("cmpxchgl   %s, " MEM_ob, GPReg32Name(src), ADDR_ob(offset, base));
         m_formatter.twoByteOp(OP2_CMPXCHG_GvEw, offset, base, src);
     }
-    void cmpxchg32(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
+    void cmpxchgl(RegisterID src, int32_t offset, RegisterID base, RegisterID index, int scale)
     {
-        spew("cmpxchg32  %s, " MEM_obs, GPRegName(src), ADDR_obs(offset, base, index, scale));
+        spew("cmpxchgl   %s, " MEM_obs, GPReg32Name(src), ADDR_obs(offset, base, index, scale));
         m_formatter.twoByteOp(OP2_CMPXCHG_GvEw, offset, base, index, scale, src);
     }
 
@@ -1755,7 +1905,7 @@ class BaseAssembler : public GenericAssembler {
     void movb_ir(int32_t imm, RegisterID reg)
     {
         spew("movb       $0x%x, %s", imm, GPReg8Name(reg));
-        m_formatter.oneByteOp(OP_MOV_EbGv, reg);
+        m_formatter.oneByteOp8(OP_MOV_EbIb, reg);
         m_formatter.immediate8(imm);
     }
 
@@ -4700,6 +4850,13 @@ threeByteOpImmSimd("vblendps", VEX_PD, OP3_BLENDPS_VpsWpsIb, ESCAPE_3A, imm, off
             m_buffer.putByteUnchecked(opcode);
         }
 
+        void oneByteOp8(OneByteOpcodeID opcode, RegisterID r)
+        {
+            m_buffer.ensureSpace(MaxInstructionSize);
+            emitRexIf(byteRegRequiresRex(r), 0, 0, r);
+            m_buffer.putByteUnchecked(opcode + (r & 7));
+        }
+
         void oneByteOp8(OneByteOpcodeID opcode, RegisterID rm, GroupOpcodeID groupOp)
         {
             m_buffer.ensureSpace(MaxInstructionSize);
@@ -4760,6 +4917,26 @@ threeByteOpImmSimd("vblendps", VEX_PD, OP3_BLENDPS_VpsWpsIb, ESCAPE_3A, imm, off
             registerModRM(rm, reg);
         }
 
+        void twoByteOp8(TwoByteOpcodeID opcode, int32_t offset, RegisterID base, RegisterID reg)
+        {
+            m_buffer.ensureSpace(MaxInstructionSize);
+            emitRexIf(byteRegRequiresRex(reg)|regRequiresRex(base), reg, 0, base);
+            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
+            m_buffer.putByteUnchecked(opcode);
+            memoryModRM(offset, base, reg);
+        }
+
+        void twoByteOp8(TwoByteOpcodeID opcode, int32_t offset, RegisterID base, RegisterID index,
+                        int scale, RegisterID reg)
+        {
+            m_buffer.ensureSpace(MaxInstructionSize);
+            emitRexIf(byteRegRequiresRex(reg)|regRequiresRex(base)|regRequiresRex(index),
+                      reg, index, base);
+            m_buffer.putByteUnchecked(OP_2BYTE_ESCAPE);
+            m_buffer.putByteUnchecked(opcode);
+            memoryModRM(offset, base, index, scale, reg);
+        }
+
         // Like twoByteOp8 but doesn't add a REX prefix if the destination reg
         // is in esp..edi. This may be used when the destination is not an 8-bit
         // register (as in a movzbl instruction), so it doesn't need a REX
@@ -4947,7 +5124,8 @@ threeByteOpImmSimd("vblendps", VEX_PD, OP3_BLENDPS_VpsWpsIb, ESCAPE_3A, imm, off
         //
         // NB: WebKit's use of emitRexIf() is limited such that the
         // reqRequiresRex() checks are not needed. SpiderMonkey extends
-        // oneByteOp8 functionality such that r, x, and b can all be used.
+        // oneByteOp8 and twoByteOp8 functionality such that r, x, and b
+        // can all be used.
         void emitRexIf(bool condition, int r, int x, int b)
         {
             if (condition ||
diff --git a/js/src/jit/shared/Encoding-x86-shared.h b/js/src/jit/shared/Encoding-x86-shared.h
index 1c2360b0a21f..a96ad4022dad 100644
--- a/js/src/jit/shared/Encoding-x86-shared.h
+++ b/js/src/jit/shared/Encoding-x86-shared.h
@@ -89,6 +89,7 @@ enum OneByteOpcodeID {
     OP_MOV_OvEAX                    = 0xA3,
     OP_TEST_EAXIb                   = 0xA8,
     OP_TEST_EAXIv                   = 0xA9,
+    OP_MOV_EbIb                     = 0xB0,
     OP_MOV_EAXIv                    = 0xB8,
     OP_GROUP2_EvIb                  = 0xC1,
     OP_RET_Iz                       = 0xC2,
diff --git a/js/src/jit/shared/MacroAssembler-x86-shared.h b/js/src/jit/shared/MacroAssembler-x86-shared.h
index 9168268e7713..8af56ba28fd6 100644
--- a/js/src/jit/shared/MacroAssembler-x86-shared.h
+++ b/js/src/jit/shared/MacroAssembler-x86-shared.h
@@ -16,6 +16,23 @@
 # include "jit/x64/Assembler-x64.h"
 #endif
 
+#ifdef DEBUG
+  #define CHECK_BYTEREG(reg)                                    \
+      JS_BEGIN_MACRO                                            \
+        GeneralRegisterSet byteRegs(Registers::SingleByteRegs); \
+        MOZ_ASSERT(byteRegs.has(reg));                          \
+      JS_END_MACRO
+  #define CHECK_BYTEREGS(r1, r2)                                \
+      JS_BEGIN_MACRO                                            \
+        GeneralRegisterSet byteRegs(Registers::SingleByteRegs); \
+        MOZ_ASSERT(byteRegs.has(r1));                           \
+        MOZ_ASSERT(byteRegs.has(r2));                           \
+      JS_END_MACRO
+#else
+  #define CHECK_BYTEREG(reg) (void)0
+  #define CHECK_BYTEREGS(r1, r2) (void)0
+#endif
+
 namespace js {
 namespace jit {
 
@@ -211,25 +228,10 @@ class MacroAssemblerX86Shared : public Assembler
     void atomic_dec32(const Operand &addr) {
         lock_decl(addr);
     }
-    void atomic_cmpxchg8(Register newval, const Operand &addr, Register oldval_and_result) {
-        // %eax must be explicitly provided for calling clarity.
-        MOZ_ASSERT(oldval_and_result.code() == X86Encoding::rax);
-        lock_cmpxchg8(newval, addr);
-    }
-    void atomic_cmpxchg16(Register newval, const Operand &addr, Register oldval_and_result) {
-        // %eax must be explicitly provided for calling clarity.
-        MOZ_ASSERT(oldval_and_result.code() == X86Encoding::rax);
-        lock_cmpxchg16(newval, addr);
-    }
-    void atomic_cmpxchg32(Register newval, const Operand &addr, Register oldval_and_result) {
-        // %eax must be explicitly provided for calling clarity.
-        MOZ_ASSERT(oldval_and_result.code() == X86Encoding::rax);
-        lock_cmpxchg32(newval, addr);
-    }
 
     template <typename T>
     void atomicFetchAdd8SignExtend(Register src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREGS(src, output);
         if (src != output)
             movl(src, output);
         lock_xaddb(output, Operand(mem));
@@ -238,7 +240,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchAdd8ZeroExtend(Register src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREGS(src, output);
         MOZ_ASSERT(temp == InvalidReg);
         if (src != output)
             movl(src, output);
@@ -248,7 +250,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchAdd8SignExtend(Imm32 src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREG(output);
         MOZ_ASSERT(temp == InvalidReg);
         movb(src, output);
         lock_xaddb(output, Operand(mem));
@@ -257,7 +259,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchAdd8ZeroExtend(Imm32 src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREG(output);
         MOZ_ASSERT(temp == InvalidReg);
         movb(src, output);
         lock_xaddb(output, Operand(mem));
@@ -315,7 +317,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchSub8SignExtend(Register src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREGS(src, output);
         MOZ_ASSERT(temp == InvalidReg);
         if (src != output)
             movl(src, output);
@@ -326,7 +328,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchSub8ZeroExtend(Register src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREGS(src, output);
         MOZ_ASSERT(temp == InvalidReg);
         if (src != output)
             movl(src, output);
@@ -337,7 +339,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchSub8SignExtend(Imm32 src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREG(output);
         MOZ_ASSERT(temp == InvalidReg);
         movb(Imm32(-src.value), output);
         lock_xaddb(output, Operand(mem));
@@ -346,7 +348,7 @@ class MacroAssemblerX86Shared : public Assembler
 
     template <typename T>
     void atomicFetchSub8ZeroExtend(Imm32 src, const T &mem, Register temp, Register output) {
-        MOZ_ASSERT(output == eax);
+        CHECK_BYTEREG(output);
         MOZ_ASSERT(temp == InvalidReg);
         movb(Imm32(-src.value), output);
         lock_xaddb(output, Operand(mem));
@@ -405,89 +407,95 @@ class MacroAssemblerX86Shared : public Assembler
     }
 
     // requires output == eax
-#define ATOMIC_BITOP_BODY(LOAD, OP, LOCK_CMPXCHG)        \
-        MOZ_ASSERT(output == eax); \
-        LOAD(Operand(mem), eax);  \
-        Label again;              \
-        bind(&again);             \
-        movl(eax, temp);          \
-        OP(src, temp);            \
-        LOCK_CMPXCHG(temp, Operand(mem)); \
+#define ATOMIC_BITOP_BODY(LOAD, OP, LOCK_CMPXCHG) \
+        MOZ_ASSERT(output == eax);                \
+        LOAD(Operand(mem), eax);                  \
+        Label again;                              \
+        bind(&again);                             \
+        movl(eax, temp);                          \
+        OP(src, temp);                            \
+        LOCK_CMPXCHG(temp, Operand(mem));         \
         j(NonZero, &again);
 
     template <typename S, typename T>
     void atomicFetchAnd8SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, andl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, andl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movsbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchAnd8ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, andl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, andl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movzbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchAnd16SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, andl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, andl, lock_cmpxchgw)
         movswl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchAnd16ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, andl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, andl, lock_cmpxchgw)
         movzwl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchAnd32(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movl, andl, lock_cmpxchg32)
+        ATOMIC_BITOP_BODY(movl, andl, lock_cmpxchgl)
     }
 
     template <typename S, typename T>
     void atomicFetchOr8SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, orl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, orl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movsbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchOr8ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, orl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, orl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movzbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchOr16SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, orl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, orl, lock_cmpxchgw)
         movswl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchOr16ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, orl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, orl, lock_cmpxchgw)
         movzwl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchOr32(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movl, orl, lock_cmpxchg32)
+        ATOMIC_BITOP_BODY(movl, orl, lock_cmpxchgl)
     }
 
     template <typename S, typename T>
     void atomicFetchXor8SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, xorl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, xorl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movsbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchXor8ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movb, xorl, lock_cmpxchg8)
+        ATOMIC_BITOP_BODY(movb, xorl, lock_cmpxchgb)
+        CHECK_BYTEREG(temp);
         movzbl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchXor16SignExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, xorl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, xorl, lock_cmpxchgw)
         movswl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchXor16ZeroExtend(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movw, xorl, lock_cmpxchg16)
+        ATOMIC_BITOP_BODY(movw, xorl, lock_cmpxchgw)
         movzwl(eax, eax);
     }
     template <typename S, typename T>
     void atomicFetchXor32(const S &src, const T &mem, Register temp, Register output) {
-        ATOMIC_BITOP_BODY(movl, xorl, lock_cmpxchg32)
+        ATOMIC_BITOP_BODY(movl, xorl, lock_cmpxchgl)
     }
 
 #undef ATOMIC_BITOP_BODY
@@ -716,19 +724,19 @@ class MacroAssemblerX86Shared : public Assembler
     template <typename T>
     void compareExchange8ZeroExtend(const T &mem, Register oldval, Register newval, Register output) {
         MOZ_ASSERT(output == eax);
-        MOZ_ASSERT(newval == ebx || newval == ecx || newval == edx);
+        CHECK_BYTEREG(newval);
         if (oldval != output)
             movl(oldval, output);
-        lock_cmpxchg8(newval, Operand(mem));
+        lock_cmpxchgb(newval, Operand(mem));
         movzbl(output, output);
     }
     template <typename T>
     void compareExchange8SignExtend(const T &mem, Register oldval, Register newval, Register output) {
         MOZ_ASSERT(output == eax);
-        MOZ_ASSERT(newval == ebx || newval == ecx || newval == edx);
+        CHECK_BYTEREG(newval);
         if (oldval != output)
             movl(oldval, output);
-        lock_cmpxchg8(newval, Operand(mem));
+        lock_cmpxchgb(newval, Operand(mem));
         movsbl(output, output);
     }
     void load16ZeroExtend(const Address &src, Register dest) {
@@ -746,7 +754,7 @@ class MacroAssemblerX86Shared : public Assembler
         MOZ_ASSERT(output == eax);
         if (oldval != output)
             movl(oldval, output);
-        lock_cmpxchg16(newval, Operand(mem));
+        lock_cmpxchgw(newval, Operand(mem));
         movzwl(output, output);
     }
     template <typename T>
@@ -754,7 +762,7 @@ class MacroAssemblerX86Shared : public Assembler
         MOZ_ASSERT(output == eax);
         if (oldval != output)
             movl(oldval, output);
-        lock_cmpxchg16(newval, Operand(mem));
+        lock_cmpxchgw(newval, Operand(mem));
         movswl(output, output);
     }
     void load16SignExtend(const Address &src, Register dest) {
@@ -781,7 +789,7 @@ class MacroAssemblerX86Shared : public Assembler
         MOZ_ASSERT(output == eax);
         if (oldval != output)
             movl(oldval, output);
-        lock_cmpxchg32(newval, Operand(mem));
+        lock_cmpxchgl(newval, Operand(mem));
     }
     template <typename S, typename T>
     void store32_NoSecondScratch(const S &src, const T &dest) {
@@ -1344,4 +1352,7 @@ class MacroAssemblerX86Shared : public Assembler
 } // namespace jit
 } // namespace js
 
+#undef CHECK_BYTEREG
+#undef CHECK_BYTEREGS
+
 #endif /* jit_shared_MacroAssembler_x86_shared_h */
