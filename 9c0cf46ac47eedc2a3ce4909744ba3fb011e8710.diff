diff --git a/js/src/asmjs/AsmJSModule.h b/js/src/asmjs/AsmJSModule.h
index 6d51d8496658..4aabc9bc2006 100644
--- a/js/src/asmjs/AsmJSModule.h
+++ b/js/src/asmjs/AsmJSModule.h
@@ -886,8 +886,8 @@ class AsmJSModule
         return pod.usesSignalHandlers_;
     }
     bool usesSignalHandlersForOOB() const {
-#ifdef JS_CODEGEN_X64
-        return usesSignalHandlersForInterrupt();
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+        return pod.usesSignalHandlers_;
 #else
         return false;
 #endif
diff --git a/js/src/asmjs/AsmJSSignalHandlers.cpp b/js/src/asmjs/AsmJSSignalHandlers.cpp
index f07e56f95f44..18bb6e0074d5 100644
--- a/js/src/asmjs/AsmJSSignalHandlers.cpp
+++ b/js/src/asmjs/AsmJSSignalHandlers.cpp
@@ -313,7 +313,7 @@ enum { REG_EIP = 14 };
 // the same as CONTEXT, but on Mac we use a different structure since we call
 // into the emulator code from a Mach exception handler rather than a
 // sigaction-style signal handler.
-#if defined(XP_MACOSX)
+#if defined(XP_MACOSX) && defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 # if defined(JS_CODEGEN_X64)
 struct macos_x64_context {
     x86_thread_state64_t thread;
@@ -351,6 +351,8 @@ ContextToPC(CONTEXT *context)
 #endif
 }
 
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+
 #if defined(JS_CODEGEN_X64)
 MOZ_COLD static void
 SetFPRegToNaN(size_t size, void *fp_reg)
@@ -520,6 +522,7 @@ AddressOfGPRegisterSlot(EMULATOR_CONTEXT *context, Registers::Code code)
     MOZ_CRASH();
 }
 # endif  // !XP_MACOSX
+#endif // JS_CODEGEN_X64
 
 MOZ_COLD static void
 SetRegisterToCoercedUndefined(EMULATOR_CONTEXT *context, size_t size,
@@ -714,8 +717,6 @@ EmulateHeapAccess(EMULATOR_CONTEXT *context, uint8_t *pc, uint8_t *faultingAddre
     return end;
 }
 
-#endif // JS_CODEGEN_X64
-
 #if defined(XP_WIN)
 
 static bool
@@ -743,7 +744,6 @@ HandleFault(PEXCEPTION_POINTERS exception)
     if (!activation)
         return false;
 
-# if defined(JS_CODEGEN_X64)
     const AsmJSModule &module = activation->module();
 
     // These checks aren't necessary, but, since we can, check anyway to make
@@ -780,11 +780,7 @@ HandleFault(PEXCEPTION_POINTERS exception)
         return false;
 
     *ppc = EmulateHeapAccess(context, pc, faultingAddress, heapAccess, module);
-
     return true;
-# else
-    return false;
-# endif
 }
 
 static LONG WINAPI
@@ -886,7 +882,6 @@ HandleMachException(JSRuntime *rt, const ExceptionRequest &request)
     if (!module.containsFunctionPC(pc))
         return false;
 
-# if defined(JS_CODEGEN_X64)
     // These checks aren't necessary, but, since we can, check anyway to make
     // sure we aren't covering up a real bug.
     uint8_t *faultingAddress = reinterpret_cast<uint8_t *>(request.body.code[1]);
@@ -912,9 +907,6 @@ HandleMachException(JSRuntime *rt, const ExceptionRequest &request)
         return false;
 
     return true;
-# else
-    return false;
-# endif
 }
 
 // Taken from mach_exc in /usr/include/mach/mach_exc.defs.
@@ -1100,7 +1092,6 @@ HandleFault(int signum, siginfo_t *info, void *ctx)
     if (!module.containsFunctionPC(pc))
         return false;
 
-# if defined(JS_CODEGEN_X64)
     // These checks aren't necessary, but, since we can, check anyway to make
     // sure we aren't covering up a real bug.
     uint8_t *faultingAddress = reinterpret_cast<uint8_t *>(info->si_addr);
@@ -1118,9 +1109,6 @@ HandleFault(int signum, siginfo_t *info, void *ctx)
     *ppc = EmulateHeapAccess(context, pc, faultingAddress, heapAccess, module);
 
     return true;
-# else
-    return false;
-# endif
 }
 
 static struct sigaction sPrevSEGVHandler;
@@ -1152,6 +1140,8 @@ AsmJSFaultHandler(int signum, siginfo_t *info, void *context)
 }
 #endif
 
+#endif // defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+
 static void
 RedirectIonBackedgesToInterruptCheck(JSRuntime *rt)
 {
@@ -1209,7 +1199,7 @@ JitInterruptHandler(int signum, siginfo_t *info, void *context)
 bool
 js::EnsureSignalHandlersInstalled(JSRuntime *rt)
 {
-#if defined(XP_MACOSX)
+#if defined(XP_MACOSX) && defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
     // On OSX, each JSRuntime gets its own handler thread.
     if (!rt->asmJSMachExceptionHandler.installed() && !rt->asmJSMachExceptionHandler.install(rt))
         return false;
@@ -1243,14 +1233,11 @@ js::EnsureSignalHandlersInstalled(JSRuntime *rt)
 # endif
 #endif
 
-#if defined(XP_WIN)
-    // Windows uses SuspendThread to stop the main thread from another thread,
-    // so the only handler we need is for asm.js out-of-bound faults.
-    if (!AddVectoredExceptionHandler(/* FirstHandler = */ true, AsmJSFaultHandler))
-        return false;
-#else
     // The interrupt handler allows the main thread to be paused from another
     // thread (see InterruptRunningJitCode).
+#if defined(XP_WIN)
+    // Windows uses SuspendThread to stop the main thread from another thread.
+#else
     struct sigaction interruptHandler;
     interruptHandler.sa_flags = SA_SIGINFO;
     interruptHandler.sa_sigaction = &JitInterruptHandler;
@@ -1267,11 +1254,18 @@ js::EnsureSignalHandlersInstalled(JSRuntime *rt)
     {
         MOZ_CRASH("contention for interrupt signal");
     }
+#endif // defined(XP_WIN)
 
-    // Lastly, install a SIGSEGV handler to handle safely-out-of-bounds asm.js
-    // heap access. OSX handles seg faults via the Mach exception handler above,
-    // so don't install AsmJSFaultHandler.
-# if !defined(XP_MACOSX)
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+    // Install a SIGSEGV handler to handle safely-out-of-bounds asm.js heap
+    // access.
+# if defined(XP_WIN)
+    if (!AddVectoredExceptionHandler(/* FirstHandler = */ true, AsmJSFaultHandler))
+        return false;
+# elif defined(XP_MACOSX)
+    // OSX handles seg faults via the Mach exception handler above, so don't
+    // install AsmJSFaultHandler.
+# else
     // SA_NODEFER allows us to reenter the signal handler if we crash while
     // handling the signal, and fall through to the Breakpad handler by testing
     // handlingSignal.
@@ -1281,8 +1275,8 @@ js::EnsureSignalHandlersInstalled(JSRuntime *rt)
     sigemptyset(&faultHandler.sa_mask);
     if (sigaction(SIGSEGV, &faultHandler, &sPrevSEGVHandler))
         MOZ_CRASH("unable to install segv handler");
-# endif // defined(XP_MACOSX)
-#endif // defined(XP_WIN)
+# endif
+#endif // defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 
     sResult = true;
     return true;
diff --git a/js/src/asmjs/AsmJSSignalHandlers.h b/js/src/asmjs/AsmJSSignalHandlers.h
index e4133191d92b..8d87806e0dd4 100644
--- a/js/src/asmjs/AsmJSSignalHandlers.h
+++ b/js/src/asmjs/AsmJSSignalHandlers.h
@@ -19,13 +19,13 @@
 #ifndef asmjs_AsmJSSignalHandlers_h
 #define asmjs_AsmJSSignalHandlers_h
 
-struct JSRuntime;
-
-#ifdef XP_MACOSX
+#if defined(XP_MACOSX) && defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 # include <mach/mach.h>
 # include "jslock.h"
 #endif
 
+struct JSRuntime;
+
 namespace js {
 
 // Set up any signal/exception handlers needed to execute code in the given
@@ -39,13 +39,13 @@ EnsureSignalHandlersInstalled(JSRuntime *rt);
 extern void
 InterruptRunningJitCode(JSRuntime *rt);
 
+#if defined(XP_MACOSX) && defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 // On OSX we are forced to use the lower-level Mach exception mechanism instead
 // of Unix signals. Mach exceptions are not handled on the victim's stack but
 // rather require an extra thread. For simplicity, we create one such thread
 // per JSRuntime (upon the first use of asm.js in the JSRuntime). This thread
 // and related resources are owned by AsmJSMachExceptionHandler which is owned
 // by JSRuntime.
-#ifdef XP_MACOSX
 class AsmJSMachExceptionHandler
 {
     bool installed_;
diff --git a/js/src/asmjs/AsmJSValidate.h b/js/src/asmjs/AsmJSValidate.h
index 3f681ed1593d..45c20c6cc6f2 100644
--- a/js/src/asmjs/AsmJSValidate.h
+++ b/js/src/asmjs/AsmJSValidate.h
@@ -54,6 +54,8 @@ ValidateAsmJS(ExclusiveContext *cx, AsmJSParser &parser, frontend::ParseNode *st
 // The assumed page size; dynamically checked in ValidateAsmJS.
 const size_t AsmJSPageSize = 4096;
 
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+
 // Targets define AsmJSImmediateRange to be the size of an address immediate,
 // and AsmJSCheckedImmediateRange, to be the size of an address immediate that
 // can be supported by signal-handler OOB handling.
@@ -61,8 +63,8 @@ static_assert(jit::AsmJSCheckedImmediateRange <= jit::AsmJSImmediateRange,
               "AsmJSImmediateRange should be the size of an unconstrained "
               "address immediate");
 
-#ifdef JS_CPU_X64
-// On x64, the internal ArrayBuffer data array is inflated to 4GiB (only the
+// To support the use of signal handlers for catching Out Of Bounds accesses,
+// the internal ArrayBuffer data array is inflated to 4GiB (only the
 // byteLength portion of which is accessible) so that out-of-bounds accesses
 // (made using a uint32 index) are guaranteed to raise a SIGSEGV.
 // Then, an additional extent is added to permit folding of small immediate
@@ -73,7 +75,7 @@ static const size_t AsmJSMappedSize = 4 * 1024ULL * 1024ULL * 1024ULL +
                                       jit::AsmJSCheckedImmediateRange +
                                       AsmJSPageSize;
 
-#endif
+#endif // defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 
 // From the asm.js spec Linking section:
 //  the heap object's byteLength must be either
diff --git a/js/src/configure.in b/js/src/configure.in
index da8d55cad816..7d0103d126c3 100644
--- a/js/src/configure.in
+++ b/js/src/configure.in
@@ -3162,6 +3162,11 @@ elif test "$CPU_ARCH" = "x86"; then
 elif test "$CPU_ARCH" = "x86_64"; then
     AC_DEFINE(JS_CODEGEN_X64)
     JS_CODEGEN_X64=1
+
+    dnl Signal-handler OOM checking requires large mprotected guard regions, so
+    dnl currently it is only implemented on x64.
+    AC_DEFINE(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
+    ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB=1
 elif test "$CPU_ARCH" = "arm"; then
     AC_DEFINE(JS_CODEGEN_ARM)
     JS_CODEGEN_ARM=1
@@ -3177,6 +3182,7 @@ AC_SUBST(JS_CODEGEN_MIPS)
 AC_SUBST(JS_CODEGEN_X86)
 AC_SUBST(JS_CODEGEN_X64)
 AC_SUBST(JS_CODEGEN_NONE)
+AC_SUBST(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 
 dnl ========================================================
 dnl jprof
diff --git a/js/src/jit/MIRGenerator.h b/js/src/jit/MIRGenerator.h
index 52321c30c100..c8e7afbeb025 100644
--- a/js/src/jit/MIRGenerator.h
+++ b/js/src/jit/MIRGenerator.h
@@ -204,7 +204,9 @@ class MIRGenerator
     void addAbortedPreliminaryGroup(ObjectGroup *group);
 
     Label *outOfBoundsLabel_;
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
     bool usesSignalHandlersForAsmJSOOB_;
+#endif
 
     void setForceAbort() {
         shouldForceAbort_ = true;
@@ -237,7 +239,7 @@ class MIRGenerator
         // handlers to catch errors, and if it's not proven to be within bounds.
         // We use signal-handlers on x64, but on x86 there isn't enough address
         // space for a guard region.
-#ifdef JS_CODEGEN_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
         if (usesSignalHandlersForAsmJSOOB_)
             return false;
 #endif
diff --git a/js/src/jit/MIRGraph.cpp b/js/src/jit/MIRGraph.cpp
index f1dbc1874366..5869e03e7359 100644
--- a/js/src/jit/MIRGraph.cpp
+++ b/js/src/jit/MIRGraph.cpp
@@ -42,7 +42,9 @@ MIRGenerator::MIRGenerator(CompileCompartment *compartment, const JitCompileOpti
     instrumentedProfilingIsCached_(false),
     nurseryObjects_(*alloc),
     outOfBoundsLabel_(outOfBoundsLabel),
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
     usesSignalHandlersForAsmJSOOB_(usesSignalHandlersForAsmJSOOB),
+#endif
     options(options)
 { }
 
diff --git a/js/src/vm/ArrayBufferObject.cpp b/js/src/vm/ArrayBufferObject.cpp
index c86869a63adc..b9cc9bce18ec 100644
--- a/js/src/vm/ArrayBufferObject.cpp
+++ b/js/src/vm/ArrayBufferObject.cpp
@@ -234,7 +234,7 @@ ArrayBufferObject::fun_isView(JSContext *cx, unsigned argc, Value *vp)
     return true;
 }
 
-#ifdef JS_CPU_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 static void
 ReleaseAsmJSMappedData(void *base)
 {
@@ -256,12 +256,12 @@ ReleaseAsmJSMappedData(void *base)
 static void
 ReleaseAsmJSMappedData(void *base)
 {
-    MOZ_CRASH("Only x64 has asm.js mapped buffers");
+    MOZ_CRASH("asm.js only uses mapped buffers when using signal-handler OOB checking");
 }
 #endif
 
 #ifdef NIGHTLY_BUILD
-# ifdef JS_CPU_X64
+# if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 static bool
 TransferAsmJSMappedBuffer(JSContext *cx, CallArgs args, Handle<ArrayBufferObject*> oldBuffer,
                           size_t newByteLength)
@@ -329,7 +329,7 @@ TransferAsmJSMappedBuffer(JSContext *cx, CallArgs args, Handle<ArrayBufferObject
     args.rval().setObject(*newBuffer);
     return true;
 }
-# endif  // defined(JS_CPU_X64)
+# endif  // defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 
 /*
  * Experimental implementation of ArrayBuffer.transfer:
@@ -393,7 +393,7 @@ ArrayBufferObject::fun_transfer(JSContext *cx, unsigned argc, Value *vp)
         if (!ArrayBufferObject::neuter(cx, oldBuffer, oldBuffer->contents()))
             return false;
     } else {
-# ifdef JS_CPU_X64
+# if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
         // With a 4gb mapped asm.js buffer, we can simply enable/disable access
         // to the delta as long as the requested length is page-sized.
         if (oldBuffer->isAsmJSMapped() && (newByteLength % AsmJSPageSize) == 0)
@@ -619,7 +619,7 @@ ArrayBufferObject::prepareForAsmJSNoSignals(JSContext *cx, Handle<ArrayBufferObj
     return true;
 }
 
-#ifdef JS_CODEGEN_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 /* static */ bool
 ArrayBufferObject::prepareForAsmJS(JSContext *cx, Handle<ArrayBufferObject*> buffer,
                                    bool usesSignalHandlers)
@@ -685,13 +685,12 @@ ArrayBufferObject::prepareForAsmJS(JSContext *cx, Handle<ArrayBufferObject*> buf
 
     return true;
 }
-#else // JS_CODEGEN_X64
+#else // ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB
 bool
 ArrayBufferObject::prepareForAsmJS(JSContext *cx, Handle<ArrayBufferObject*> buffer,
                                    bool usesSignalHandlers)
 {
-    // Platforms other than x64 don't use signalling for bounds checking, so
-    // just use the variant with no signals.
+    // Just use the variant with no signals.
     MOZ_ASSERT(!usesSignalHandlers);
     return prepareForAsmJSNoSignals(cx, buffer);
 }
diff --git a/js/src/vm/Runtime.h b/js/src/vm/Runtime.h
index 6fbfd208fca9..6a45b7d0d619 100644
--- a/js/src/vm/Runtime.h
+++ b/js/src/vm/Runtime.h
@@ -1090,7 +1090,7 @@ struct JSRuntime : public JS::shadow::Runtime,
     /* Client opaque pointers */
     void                *data;
 
-#ifdef XP_MACOSX
+#if defined(XP_MACOSX) && defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
     js::AsmJSMachExceptionHandler asmJSMachExceptionHandler;
 #endif
 
diff --git a/js/src/vm/SharedArrayObject.cpp b/js/src/vm/SharedArrayObject.cpp
index 925aa582283f..9273b317c519 100644
--- a/js/src/vm/SharedArrayObject.cpp
+++ b/js/src/vm/SharedArrayObject.cpp
@@ -67,7 +67,7 @@ MarkValidRegion(void *addr, size_t len)
 #endif
 }
 
-#ifdef JS_CODEGEN_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
 // Since this SharedArrayBuffer will likely be used for asm.js code, prepare it
 // for asm.js by mapping the 4gb protected zone described in AsmJSValidate.h.
 // Since we want to put the SharedArrayBuffer header immediately before the
@@ -97,7 +97,7 @@ SharedArrayRawBuffer::New(JSContext *cx, uint32_t length)
     uint32_t allocSize = (length + 2*AsmJSPageSize - 1) & ~(AsmJSPageSize - 1);
     if (allocSize <= length)
         return nullptr;
-#ifdef JS_CODEGEN_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
     // Test >= to guard against the case where multiple extant runtimes
     // race to allocate.
     if (++numLive >= maxLive) {
@@ -153,7 +153,7 @@ SharedArrayRawBuffer::dropReference()
     if (refcount == 0) {
         uint8_t *p = this->dataPointer() - AsmJSPageSize;
         MOZ_ASSERT(uintptr_t(p) % AsmJSPageSize == 0);
-#ifdef JS_CODEGEN_X64
+#if defined(ASMJS_MAY_USE_SIGNAL_HANDLERS_FOR_OOB)
         numLive--;
         UnmapMemory(p, SharedArrayMappedSize);
 #       if defined(MOZ_VALGRIND) \
