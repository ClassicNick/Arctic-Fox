diff --git a/js/xpconnect/loader/mozJSComponentLoader.cpp b/js/xpconnect/loader/mozJSComponentLoader.cpp
index f8d3aa1a13b9..c35a597a3cca 100644
--- a/js/xpconnect/loader/mozJSComponentLoader.cpp
+++ b/js/xpconnect/loader/mozJSComponentLoader.cpp
@@ -116,7 +116,7 @@ Dump(JSContext* cx, unsigned argc, Value* vp)
 }
 
 static bool
-Debug(JSContext* cx, unsigned argc, jsval* vp)
+Debug(JSContext* cx, unsigned argc, Value* vp)
 {
 #ifdef DEBUG
     return Dump(cx, argc, vp);
diff --git a/js/xpconnect/src/Sandbox.cpp b/js/xpconnect/src/Sandbox.cpp
index bcbdaf1b8df7..269ba3a12851 100644
--- a/js/xpconnect/src/Sandbox.cpp
+++ b/js/xpconnect/src/Sandbox.cpp
@@ -110,7 +110,7 @@ xpc::NewSandboxConstructor()
 }
 
 static bool
-SandboxDump(JSContext* cx, unsigned argc, jsval* vp)
+SandboxDump(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -147,7 +147,7 @@ SandboxDump(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-SandboxDebug(JSContext* cx, unsigned argc, jsval* vp)
+SandboxDebug(JSContext* cx, unsigned argc, Value* vp)
 {
 #ifdef DEBUG
     return SandboxDump(cx, argc, vp);
@@ -299,7 +299,7 @@ SandboxFetch(JSContext* cx, JS::HandleObject scope, const CallArgs& args)
     return true;
 }
 
-static bool SandboxFetchPromise(JSContext* cx, unsigned argc, jsval* vp)
+static bool SandboxFetchPromise(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     RootedObject callee(cx, &args.callee());
@@ -323,7 +323,7 @@ SandboxCreateFetch(JSContext* cx, HandleObject obj)
 }
 
 static bool
-SandboxIsProxy(JSContext* cx, unsigned argc, jsval* vp)
+SandboxIsProxy(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (args.length() < 1) {
@@ -350,7 +350,7 @@ SandboxIsProxy(JSContext* cx, unsigned argc, jsval* vp)
  *                         [optional] object options)
  */
 static bool
-SandboxExportFunction(JSContext* cx, unsigned argc, jsval* vp)
+SandboxExportFunction(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (args.length() < 2) {
@@ -363,7 +363,7 @@ SandboxExportFunction(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-SandboxCreateObjectIn(JSContext* cx, unsigned argc, jsval* vp)
+SandboxCreateObjectIn(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (args.length() < 1) {
@@ -389,7 +389,7 @@ SandboxCreateObjectIn(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-SandboxCloneInto(JSContext* cx, unsigned argc, jsval* vp)
+SandboxCloneInto(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     if (args.length() < 2) {
diff --git a/js/xpconnect/src/XPCCallContext.cpp b/js/xpconnect/src/XPCCallContext.cpp
index 57b891108af1..7dd594900394 100644
--- a/js/xpconnect/src/XPCCallContext.cpp
+++ b/js/xpconnect/src/XPCCallContext.cpp
@@ -22,8 +22,8 @@ XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
                                HandleObject funobj /* = nullptr               */,
                                HandleId name       /* = JSID_VOID             */,
                                unsigned argc       /* = NO_ARGS               */,
-                               jsval* argv         /* = nullptr               */,
-                               jsval* rval         /* = nullptr               */)
+                               Value* argv         /* = nullptr               */,
+                               Value* rval         /* = nullptr               */)
     :   mAr(cx),
         mState(INIT_FAILED),
         mXPC(nsXPConnect::XPConnect()),
@@ -166,8 +166,8 @@ XPCCallContext::SetCallInfo(XPCNativeInterface* iface, XPCNativeMember* member,
 
 void
 XPCCallContext::SetArgsAndResultPtr(unsigned argc,
-                                    jsval* argv,
-                                    jsval* rval)
+                                    Value* argv,
+                                    Value* rval)
 {
     CHECK_STATE(HAVE_OBJECT);
 
@@ -287,7 +287,7 @@ XPCCallContext::GetArgc(uint32_t* aArgc)
 
 /* readonly attribute JSValPtr ArgvPtr; */
 NS_IMETHODIMP
-XPCCallContext::GetArgvPtr(jsval * *aArgvPtr)
+XPCCallContext::GetArgvPtr(Value** aArgvPtr)
 {
     *aArgvPtr = mArgv;
     return NS_OK;
diff --git a/js/xpconnect/src/XPCConvert.cpp b/js/xpconnect/src/XPCConvert.cpp
index 367602b717f6..8beffbe3b6b1 100644
--- a/js/xpconnect/src/XPCConvert.cpp
+++ b/js/xpconnect/src/XPCConvert.cpp
@@ -460,7 +460,7 @@ XPCConvert::JSData2Native(void* d, HandleValue s,
         break;
     }
     case nsXPTType::T_JSVAL :
-        *((jsval*)d) = s;
+        *((Value*)d) = s;
         break;
     case nsXPTType::T_VOID:
         XPC_LOG_ERROR(("XPCConvert::JSData2Native : void* params not supported"));
@@ -969,7 +969,7 @@ XPCConvert::ConstructException(nsresult rv, const char* message,
                                nsISupports* data,
                                nsIException** exceptn,
                                JSContext* cx,
-                               jsval* jsExceptionPtr)
+                               Value* jsExceptionPtr)
 {
     MOZ_ASSERT(!cx == !jsExceptionPtr, "Expected cx and jsExceptionPtr to cooccur.");
 
@@ -1159,7 +1159,7 @@ XPCConvert::JSValToXPCException(MutableHandleValue s,
                                       nullptr, exceptn, cx, s.address());
         else {
             // XXX all this nsISupportsDouble code seems a little redundant
-            // now that we're storing the jsval in the exception...
+            // now that we're storing the Value in the exception...
             nsISupportsDouble* data;
             nsCOMPtr<nsIComponentManager> cm;
             if (NS_FAILED(NS_GetComponentManager(getter_AddRefs(cm))) || !cm ||
diff --git a/js/xpconnect/src/XPCInlines.h b/js/xpconnect/src/XPCInlines.h
index f73db94fa46b..b33eba5146a6 100644
--- a/js/xpconnect/src/XPCInlines.h
+++ b/js/xpconnect/src/XPCInlines.h
@@ -187,14 +187,14 @@ XPCCallContext::GetArgc() const
     return mArgc;
 }
 
-inline jsval*
+inline JS::Value*
 XPCCallContext::GetArgv() const
 {
     CHECK_STATE(READY_TO_CALL);
     return mArgv;
 }
 
-inline jsval*
+inline JS::Value*
 XPCCallContext::GetRetVal() const
 {
     CHECK_STATE(READY_TO_CALL);
@@ -202,7 +202,7 @@ XPCCallContext::GetRetVal() const
 }
 
 inline void
-XPCCallContext::SetRetVal(jsval val)
+XPCCallContext::SetRetVal(JS::Value val)
 {
     CHECK_STATE(HAVE_ARGS);
     if (mRetVal)
diff --git a/js/xpconnect/src/XPCShellImpl.cpp b/js/xpconnect/src/XPCShellImpl.cpp
index fd02323c23fe..61290e0f41b4 100644
--- a/js/xpconnect/src/XPCShellImpl.cpp
+++ b/js/xpconnect/src/XPCShellImpl.cpp
@@ -211,7 +211,7 @@ GetLine(JSContext* cx, char* bufp, FILE* file, const char* prompt)
 }
 
 static bool
-ReadLine(JSContext* cx, unsigned argc, jsval* vp)
+ReadLine(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -255,7 +255,7 @@ ReadLine(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-Print(JSContext* cx, unsigned argc, jsval* vp)
+Print(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     args.rval().setUndefined();
@@ -283,7 +283,7 @@ Print(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-Dump(JSContext* cx, unsigned argc, jsval* vp)
+Dump(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     args.rval().setUndefined();
@@ -316,7 +316,7 @@ Dump(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-Load(JSContext* cx, unsigned argc, jsval* vp)
+Load(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -365,7 +365,7 @@ Load(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-Version(JSContext* cx, unsigned argc, jsval* vp)
+Version(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     args.rval().setInt32(JS_GetVersion(cx));
@@ -376,7 +376,7 @@ Version(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-Quit(JSContext* cx, unsigned argc, jsval* vp)
+Quit(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -390,7 +390,7 @@ Quit(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-DumpXPC(JSContext* cx, unsigned argc, jsval* vp)
+DumpXPC(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -408,7 +408,7 @@ DumpXPC(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-GC(JSContext* cx, unsigned argc, jsval* vp)
+GC(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     JSRuntime* rt = JS_GetRuntime(cx);
@@ -422,7 +422,7 @@ GC(JSContext* cx, unsigned argc, jsval* vp)
 
 #ifdef JS_GC_ZEAL
 static bool
-GCZeal(JSContext* cx, unsigned argc, jsval* vp)
+GCZeal(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     uint32_t zeal;
@@ -466,7 +466,7 @@ SendCommand(JSContext* cx, unsigned argc, Value* vp)
 }
 
 static bool
-Options(JSContext* cx, unsigned argc, jsval* vp)
+Options(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = CallArgsFromVp(argc, vp);
     RuntimeOptions oldRuntimeOptions = RuntimeOptionsRef(cx);
@@ -571,7 +571,7 @@ XPCShellInterruptCallback(JSContext* cx)
 }
 
 static bool
-SetInterruptCallback(JSContext* cx, unsigned argc, jsval* vp)
+SetInterruptCallback(JSContext* cx, unsigned argc, Value* vp)
 {
     MOZ_ASSERT(sScriptedInterruptCallback.initialized());
 
@@ -600,7 +600,7 @@ SetInterruptCallback(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-SimulateActivityCallback(JSContext* cx, unsigned argc, jsval* vp)
+SimulateActivityCallback(JSContext* cx, unsigned argc, Value* vp)
 {
     // Sanity-check args.
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
@@ -613,7 +613,7 @@ SimulateActivityCallback(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-RegisterAppManifest(JSContext* cx, unsigned argc, jsval* vp)
+RegisterAppManifest(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
     if (args.length() != 1) {
diff --git a/js/xpconnect/src/XPCVariant.cpp b/js/xpconnect/src/XPCVariant.cpp
index 9e04621035c0..c18400f896d0 100644
--- a/js/xpconnect/src/XPCVariant.cpp
+++ b/js/xpconnect/src/XPCVariant.cpp
@@ -29,7 +29,7 @@ NS_IMPL_CI_INTERFACE_GETTER(XPCVariant, XPCVariant, nsIVariant)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(XPCVariant)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(XPCVariant)
 
-XPCVariant::XPCVariant(JSContext* cx, jsval aJSVal)
+XPCVariant::XPCVariant(JSContext* cx, Value aJSVal)
     : mJSVal(aJSVal), mCCGeneration(0)
 {
     nsVariant::Initialize(&mData);
@@ -55,7 +55,7 @@ XPCVariant::XPCVariant(JSContext* cx, jsval aJSVal)
 
 XPCTraceableVariant::~XPCTraceableVariant()
 {
-    jsval val = GetJSValPreserveColor();
+    Value val = GetJSValPreserveColor();
 
     MOZ_ASSERT(val.isGCThing(), "Must be traceable or unlinked");
 
@@ -97,7 +97,7 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 // static
 already_AddRefed<XPCVariant>
-XPCVariant::newVariant(JSContext* cx, jsval aJSVal)
+XPCVariant::newVariant(JSContext* cx, Value aJSVal)
 {
     nsRefPtr<XPCVariant> variant;
 
diff --git a/js/xpconnect/src/XPCWrappedJSClass.cpp b/js/xpconnect/src/XPCWrappedJSClass.cpp
index 1619108c4cbe..572a0e7e33f7 100644
--- a/js/xpconnect/src/XPCWrappedJSClass.cpp
+++ b/js/xpconnect/src/XPCWrappedJSClass.cpp
@@ -322,7 +322,7 @@ nsXPCWrappedJSClass::GetNamedPropertyAsVariant(XPCCallContext& ccx,
     if (!scriptEval.StartEvaluating(aJSObj))
         return NS_ERROR_FAILURE;
 
-    // Wrap the string in a jsval after the AutoScriptEvaluate, so that the
+    // Wrap the string in a Value after the AutoScriptEvaluate, so that the
     // resulting value ends up in the correct compartment.
     nsStringBuffer* buf;
     RootedValue value(cx);
@@ -943,8 +943,8 @@ nsXPCWrappedJSClass::CallMethod(nsXPCWrappedJS* wrapper, uint16_t methodIndex,
                                 const XPTMethodDescriptor* info_,
                                 nsXPTCMiniVariant* nativeParams)
 {
-    jsval* sp = nullptr;
-    jsval* argv = nullptr;
+    Value* sp = nullptr;
+    Value* argv = nullptr;
     uint8_t i;
     nsresult retval = NS_ERROR_FAILURE;
     bool success;
diff --git a/js/xpconnect/src/XPCWrappedNative.cpp b/js/xpconnect/src/XPCWrappedNative.cpp
index e96eb385abd6..a7420b55f177 100644
--- a/js/xpconnect/src/XPCWrappedNative.cpp
+++ b/js/xpconnect/src/XPCWrappedNative.cpp
@@ -1299,7 +1299,7 @@ class MOZ_STACK_CLASS CallMethodHelper
     uint8_t mJSContextIndex; // TODO make const
     uint8_t mOptArgcIndex; // TODO make const
 
-    jsval* const mArgv;
+    Value* const mArgv;
     const uint32_t mArgc;
 
     MOZ_ALWAYS_INLINE bool
@@ -1559,7 +1559,7 @@ CallMethodHelper::GetOutParamSource(uint8_t paramIndex, MutableHandleValue srcp)
     if (paramInfo.IsOut() && !paramInfo.IsRetval()) {
         MOZ_ASSERT(paramIndex < mArgc || paramInfo.IsOptional(),
                    "Expected either enough arguments or an optional argument");
-        jsval arg = paramIndex < mArgc ? mArgv[paramIndex] : JS::NullValue();
+        Value arg = paramIndex < mArgc ? mArgv[paramIndex] : JS::NullValue();
         if (paramIndex < mArgc) {
             RootedObject obj(mCallContext);
             if (!arg.isPrimitive())
@@ -2040,7 +2040,7 @@ CallMethodHelper::CleanupParam(nsXPTCMiniVariant& param, nsXPTType& type)
 
     switch (type.TagPart()) {
         case nsXPTType::T_JSVAL:
-            js::RemoveRawValueRoot(mCallContext, (jsval*)&param.val);
+            js::RemoveRawValueRoot(mCallContext, (Value*)&param.val);
             break;
         case nsXPTType::T_INTERFACE:
         case nsXPTType::T_INTERFACE_IS:
diff --git a/js/xpconnect/src/XPCWrappedNativeInfo.cpp b/js/xpconnect/src/XPCWrappedNativeInfo.cpp
index 79170f90cb59..48816435fae8 100644
--- a/js/xpconnect/src/XPCWrappedNativeInfo.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeInfo.cpp
@@ -27,7 +27,7 @@ XPCNativeMember::GetCallInfo(JSObject* funobj,
                              XPCNativeMember**    pMember)
 {
     funobj = js::UncheckedUnwrap(funobj);
-    jsval memberVal =
+    Value memberVal =
         js::GetFunctionNativeReserved(funobj,
                                       XPC_FUNCTION_NATIVE_MEMBER_SLOT);
 
@@ -40,7 +40,7 @@ XPCNativeMember::GetCallInfo(JSObject* funobj,
 bool
 XPCNativeMember::NewFunctionObject(XPCCallContext& ccx,
                                    XPCNativeInterface* iface, HandleObject parent,
-                                   jsval* pval)
+                                   Value* pval)
 {
     MOZ_ASSERT(!IsConstant(), "Only call this if you're sure this is not a constant!");
 
@@ -49,7 +49,7 @@ XPCNativeMember::NewFunctionObject(XPCCallContext& ccx,
 
 bool
 XPCNativeMember::Resolve(XPCCallContext& ccx, XPCNativeInterface* iface,
-                         HandleObject parent, jsval* vp)
+                         HandleObject parent, Value* vp)
 {
     MOZ_ASSERT(iface == GetInterface());
     if (IsConstant()) {
diff --git a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
index a3f62b34098c..80ce3202347d 100644
--- a/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
+++ b/js/xpconnect/src/XPCWrappedNativeJSOps.cpp
@@ -68,7 +68,7 @@ ToStringGuts(XPCCallContext& ccx)
 /***************************************************************************/
 
 static bool
-XPC_WN_Shared_ToString(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_Shared_ToString(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     RootedObject obj(cx, JS_THIS_OBJECT(cx, vp));
@@ -84,7 +84,7 @@ XPC_WN_Shared_ToString(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-XPC_WN_Shared_ToSource(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_Shared_ToSource(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
     static const char empty[] = "({})";
@@ -136,7 +136,7 @@ GetDoubleWrappedJSObject(XPCCallContext& ccx, XPCWrappedNative* wrapper)
 // double wrapped JSObjects.
 
 static bool
-XPC_WN_DoubleWrappedGetter(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_DoubleWrappedGetter(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
 
@@ -778,7 +778,7 @@ XPC_WN_Helper_SetProperty(JSContext* cx, HandleObject obj, HandleId id,
 }
 
 static bool
-XPC_WN_Helper_Call(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_Helper_Call(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
     // N.B. we want obj to be the callee, not JS_THIS(cx, vp)
@@ -795,7 +795,7 @@ XPC_WN_Helper_Call(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-XPC_WN_Helper_Construct(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_Helper_Construct(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
     RootedObject obj(cx, &args.callee());
@@ -1119,7 +1119,7 @@ FixUpThisIfBroken(JSObject* obj, JSObject* funobj)
 }
 
 bool
-XPC_WN_CallMethod(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_CallMethod(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
     MOZ_ASSERT(JS_TypeOfValue(cx, args.calleev()) == JSTYPE_FUNCTION, "bad function");
@@ -1145,7 +1145,7 @@ XPC_WN_CallMethod(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 bool
-XPC_WN_GetterSetter(JSContext* cx, unsigned argc, jsval* vp)
+XPC_WN_GetterSetter(JSContext* cx, unsigned argc, Value* vp)
 {
     JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
     MOZ_ASSERT(JS_TypeOfValue(cx, args.calleev()) == JSTYPE_FUNCTION, "bad function");
diff --git a/js/xpconnect/src/XPCWrapper.cpp b/js/xpconnect/src/XPCWrapper.cpp
index 1c8b41944427..a6b331017fb0 100644
--- a/js/xpconnect/src/XPCWrapper.cpp
+++ b/js/xpconnect/src/XPCWrapper.cpp
@@ -11,6 +11,7 @@
 
 using namespace xpc;
 using namespace mozilla;
+using namespace JS;
 
 namespace XPCNativeWrapper {
 
@@ -24,7 +25,7 @@ ThrowException(nsresult ex, JSContext* cx)
 }
 
 static bool
-UnwrapNW(JSContext* cx, unsigned argc, jsval* vp)
+UnwrapNW(JSContext* cx, unsigned argc, Value* vp)
 {
   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
   if (args.length() != 1) {
@@ -45,7 +46,7 @@ UnwrapNW(JSContext* cx, unsigned argc, jsval* vp)
 }
 
 static bool
-XrayWrapperConstructor(JSContext* cx, unsigned argc, jsval* vp)
+XrayWrapperConstructor(JSContext* cx, unsigned argc, Value* vp)
 {
   JS::CallArgs args = CallArgsFromVp(argc, vp);
   if (args.length() == 0) {
diff --git a/js/xpconnect/src/xpcprivate.h b/js/xpconnect/src/xpcprivate.h
index 904d3d02cd9d..70205ee0dead 100644
--- a/js/xpconnect/src/xpcprivate.h
+++ b/js/xpconnect/src/xpcprivate.h
@@ -635,7 +635,7 @@ class XPCJSRuntime : public mozilla::CycleCollectedJSRuntime
 
     static const char* const mStrings[IDX_TOTAL_COUNT];
     jsid mStrIDs[IDX_TOTAL_COUNT];
-    jsval mStrJSVals[IDX_TOTAL_COUNT];
+    JS::Value mStrJSVals[IDX_TOTAL_COUNT];
 
     XPCJSContextStack*       mJSContextStack;
     XPCCallContext*          mCallContext;
@@ -798,7 +798,7 @@ class MOZ_STACK_CLASS XPCCallContext : public nsAXPCNativeCallContext
     NS_IMETHOD GetCalleeMethodIndex(uint16_t* aResult);
     NS_IMETHOD GetJSContext(JSContext** aResult);
     NS_IMETHOD GetArgc(uint32_t* aResult);
-    NS_IMETHOD GetArgvPtr(jsval** aResult);
+    NS_IMETHOD GetArgvPtr(JS::Value** aResult);
     NS_IMETHOD GetCalleeInterface(nsIInterfaceInfo** aResult);
     NS_IMETHOD GetCalleeClassInfo(nsIClassInfo** aResult);
     NS_IMETHOD GetPreviousCallContext(nsAXPCNativeCallContext** aResult);
@@ -814,8 +814,8 @@ class MOZ_STACK_CLASS XPCCallContext : public nsAXPCNativeCallContext
                    JS::HandleObject funobj = nullptr,
                    JS::HandleId id         = JSID_VOIDHANDLE,
                    unsigned argc           = NO_ARGS,
-                   jsval* argv             = nullptr,
-                   jsval* rval             = nullptr);
+                   JS::Value* argv         = nullptr,
+                   JS::Value* rval         = nullptr);
 
     virtual ~XPCCallContext();
 
@@ -847,8 +847,8 @@ class MOZ_STACK_CLASS XPCCallContext : public nsAXPCNativeCallContext
     inline jsid                         GetName() const ;
     inline bool                         GetStaticMemberIsLocal() const ;
     inline unsigned                     GetArgc() const ;
-    inline jsval*                       GetArgv() const ;
-    inline jsval*                       GetRetVal() const ;
+    inline JS::Value*                   GetArgv() const ;
+    inline JS::Value*                   GetRetVal() const ;
 
     inline uint16_t                     GetMethodIndex() const ;
     inline void                         SetMethodIndex(uint16_t index) ;
@@ -859,10 +859,10 @@ class MOZ_STACK_CLASS XPCCallContext : public nsAXPCNativeCallContext
     inline XPCWrappedNative* GetResolvingWrapper() const;
     inline XPCWrappedNative* SetResolvingWrapper(XPCWrappedNative* w);
 
-    inline void SetRetVal(jsval val);
+    inline void SetRetVal(JS::Value val);
 
     void SetName(jsid name);
-    void SetArgsAndResultPtr(unsigned argc, jsval* argv, jsval* rval);
+    void SetArgsAndResultPtr(unsigned argc, JS::Value* argv, JS::Value* rval);
     void SetCallInfo(XPCNativeInterface* iface, XPCNativeMember* member,
                      bool isSetter);
 
@@ -927,8 +927,8 @@ inline void CHECK_STATE(int s) const {MOZ_ASSERT(mState >= s, "bad state");}
     bool                            mStaticMemberIsLocal;
 
     unsigned                        mArgc;
-    jsval*                          mArgv;
-    jsval*                          mRetVal;
+    JS::Value*                      mArgv;
+    JS::Value*                      mRetVal;
 
     uint16_t                        mMethodIndex;
 };
@@ -956,10 +956,10 @@ extern const js::Class XPC_WN_Tearoff_JSClass;
 extern const js::Class XPC_WN_NoHelper_Proto_JSClass;
 
 extern bool
-XPC_WN_CallMethod(JSContext* cx, unsigned argc, jsval* vp);
+XPC_WN_CallMethod(JSContext* cx, unsigned argc, JS::Value* vp);
 
 extern bool
-XPC_WN_GetterSetter(JSContext* cx, unsigned argc, jsval* vp);
+XPC_WN_GetterSetter(JSContext* cx, unsigned argc, JS::Value* vp);
 
 extern JSObject*
 XPC_WN_JSOp_ThisObject(JSContext* cx, JS::HandleObject obj);
@@ -1290,13 +1290,13 @@ class XPCNativeMember
     uint16_t GetIndex() const {return mIndex;}
 
     bool GetConstantValue(XPCCallContext& ccx, XPCNativeInterface* iface,
-                          jsval* pval)
+                          JS::Value* pval)
         {MOZ_ASSERT(IsConstant(),
                     "Only call this if you're sure this is a constant!");
          return Resolve(ccx, iface, nullptr, pval);}
 
     bool NewFunctionObject(XPCCallContext& ccx, XPCNativeInterface* iface,
-                           JS::HandleObject parent, jsval* pval);
+                           JS::HandleObject parent, JS::Value* pval);
 
     bool IsMethod() const
         {return 0 != (mFlags & METHOD);}
@@ -1342,7 +1342,7 @@ class XPCNativeMember
 
 private:
     bool Resolve(XPCCallContext& ccx, XPCNativeInterface* iface,
-                 JS::HandleObject parent, jsval* vp);
+                 JS::HandleObject parent, JS::Value* vp);
 
     enum {
         METHOD      = 0x01,
@@ -2583,9 +2583,9 @@ class XPCConvert
     static bool IsMethodReflectable(const XPTMethodDescriptor& info);
 
     /**
-     * Convert a native object into a jsval.
+     * Convert a native object into a JS::Value.
      *
-     * @param d [out] the resulting jsval
+     * @param d [out] the resulting JS::Value
      * @param s the native object we're working with
      * @param type the type of object that s is
      * @param iid the interface of s that we want
@@ -2639,9 +2639,9 @@ class XPCConvert
     static bool GetISupportsFromJSObject(JSObject* obj, nsISupports** iface);
 
     /**
-     * Convert a native array into a jsval.
+     * Convert a native array into a JS::Value.
      *
-     * @param d [out] the resulting jsval
+     * @param d [out] the resulting JS::Value
      * @param s the native array we're working with
      * @param type the type of objects in the array
      * @param iid the interface of each object in the array that we want
@@ -2689,7 +2689,7 @@ class XPCConvert
                                        nsISupports* data,
                                        nsIException** exception,
                                        JSContext* cx,
-                                       jsval* jsExceptionPtr);
+                                       JS::Value* jsExceptionPtr);
 
 private:
     XPCConvert(); // not implemented
@@ -3285,21 +3285,21 @@ class XPCVariant : public nsIVariant
     // if a given nsIVariant is in fact an XPCVariant.
     NS_DECLARE_STATIC_IID_ACCESSOR(XPCVARIANT_IID)
 
-    static already_AddRefed<XPCVariant> newVariant(JSContext* cx, jsval aJSVal);
+    static already_AddRefed<XPCVariant> newVariant(JSContext* cx, JS::Value aJSVal);
 
     /**
-     * This getter clears the gray bit before handing out the jsval if the jsval
+     * This getter clears the gray bit before handing out the Value if the Value
      * represents a JSObject. That means that the object is guaranteed to be
      * kept alive past the next CC.
      */
-    jsval GetJSVal() const {
+    JS::Value GetJSVal() const {
         if (!mJSVal.isPrimitive())
             JS::ExposeObjectToActiveJS(&mJSVal.toObject());
         return mJSVal;
     }
 
     /**
-     * This getter does not change the color of the jsval (if it represents a
+     * This getter does not change the color of the Value (if it represents a
      * JSObject) meaning that the value returned is not guaranteed to be kept
      * alive past the next CC.
      *
@@ -3307,12 +3307,12 @@ class XPCVariant : public nsIVariant
      * be passed into a JS API function and that it won't be stored without
      * being rooted (or otherwise signaling the stored value to the CC).
      */
-    jsval GetJSValPreserveColor() const {return mJSVal;}
+    JS::Value GetJSValPreserveColor() const {return mJSVal;}
 
-    XPCVariant(JSContext* cx, jsval aJSVal);
+    XPCVariant(JSContext* cx, JS::Value aJSVal);
 
     /**
-     * Convert a variant into a jsval.
+     * Convert a variant into a JS::Value.
      *
      * @param ccx the context for the whole procedure
      * @param variant the variant to convert
@@ -3357,7 +3357,7 @@ class XPCTraceableVariant: public XPCVariant,
                            public XPCRootSetElem
 {
 public:
-    XPCTraceableVariant(JSContext* cx, jsval aJSVal)
+    XPCTraceableVariant(JSContext* cx, JS::Value aJSVal)
         : XPCVariant(cx, aJSVal)
     {
          nsXPConnect::GetRuntimeInstance()->AddVariantRoot(this);
@@ -3390,10 +3390,10 @@ NewAddonId(JSContext* cx, const nsACString& id);
 
 // JSNatives to expose atob and btoa in various non-DOM XPConnect scopes.
 bool
-Atob(JSContext* cx, unsigned argc, jsval* vp);
+Atob(JSContext* cx, unsigned argc, JS::Value* vp);
 
 bool
-Btoa(JSContext* cx, unsigned argc, jsval* vp);
+Btoa(JSContext* cx, unsigned argc, JS::Value* vp);
 
 // Helper function that creates a JSFunction that wraps a native function that
 // forwards the call to the original 'callable'.
